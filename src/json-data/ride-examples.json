{"eTag":"W/\"fc48b3b2ce0cf592370434e2e098ddaa7b433678\"","folders":[{"name":"auction","sha":"f4677f46dca3dea249f7c130dad94fb0690f9d4e","content":[{"name":"readme.md","content":"# Auction\n\nThis is an auction dApp.\nYou can start auction for any token(s) for some period of time (counted in blocks).\nIf somebody took part in the auction, then the organizer will get the winners bid, and the winner will get token(s).\nOnce next bid provided, the previous bid is returned to it's sender\n\n## Starting auction\nEverybody can start an auction with invokeScript 'startAuction' attaching Tokens to it.\nAuction lasts for 'duration' blocks provided as an argument to 'startAuction'.\nOrganizer also sets 'startPrice' and 'priceAsset' for bids.\n\n# Bidding\nBefore auction finish anybody can bid. The bid is only accepted if it is greater than current winning bid.\nIf the same address will bid again, his new bid will be added to the previous ones.\n\n#Withdraw\nAnyone can call 'withdraw':\nAs a result bid of the winner will be transfered to organizer and token(s) to the winner.\nIn case noone made bid, organizer will get his token(s) back.","type":"md","id":"auction/readme.md","sha":"419d6e01298ad9bb24f9106ee1245f0ce6701408","readonly":true},{"name":"ride","sha":"68a6191fa8518e5d083cedcedd5edaaec8ca3719","content":[{"name":"auction.ride","content":"{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n\nlet maxAuctionDuration = 1440 * 30 \n# ~ 30 days\n\n# priceAssetId = \"WAVES\" or assetId\n@Callable(i)\nfunc startAuction(duration: Int, startPrice: Int, priceAssetId:String) = {\n    \n    let auctionId = toBase58String(i.transactionId)\n    let endHeight = lastBlock.height + duration\n\n    let pmt = extract(i.payment)\n    \n    if (duration > maxAuctionDuration) then throw(\"Duration is too long. Must be less than \" + toString(maxAuctionDuration)) else\n    WriteSet( \n            [   DataEntry(auctionId, endHeight), \n                DataEntry(auctionId + \"_organizer\", i.caller.bytes.toBase58String()), \n                DataEntry(auctionId + \"_lot_assetId\", if (isDefined(pmt.assetId)) then toBase58String(value(pmt.assetId)) else \"WAVES\"),\n                DataEntry(auctionId + \"_lot_amount\", pmt.amount), \n                DataEntry(auctionId + \"_startPrice\", startPrice), \n                DataEntry(auctionId + \"_priceAssetId\", priceAssetId)\n            ])\n} \n\n@Callable(i)\nfunc bid(auctionId: String) = {\n\n    let pmt = extract(i.payment)\n    let pmtAssetIdStr = if (isDefined(pmt.assetId)) then toBase58String(value(pmt.assetId)) else \"WAVES\"\n    let callerAddressStr = i.caller.bytes.toBase58String()\n\n    let endHeight = getIntegerValue(this, auctionId)\n    let startPrice = getIntegerValue(this, auctionId + \"_startPrice\")\n    let priceAssetId = getStringValue(this, auctionId + \"_priceAssetId\")\n    let winAmount = getInteger(this, auctionId + \"_winAmount\")\n    let winner = getString(this, auctionId + \"_winner\")\n\n    let bidFromTheSameUser = isDefined(winner) && value(winner) == callerAddressStr\n    let totalBidAmount = pmt.amount + if bidFromTheSameUser then\n                                         value(winAmount) else 0\n\n    if (lastBlock.height >= endHeight) then \n        throw(\"Auction already finished\") else\n    if (priceAssetId != pmtAssetIdStr) then \n        throw(\"Bid must be in asset '\" + priceAssetId + \"'\") else\n    if (isDefined(winAmount) && totalBidAmount <= value(winAmount) ||\n        !isDefined(winAmount) && totalBidAmount <= startPrice) then \n        throw(\"Bid must be more then \" \n           + toString(if isDefined(winAmount) then value(winAmount) else startPrice)) \n    else\n        if (bidFromTheSameUser || !isDefined(winner)) then\n            WriteSet([\n                DataEntry(auctionId + \"_winner\", callerAddressStr),\n                DataEntry(auctionId + \"_winAmount\", totalBidAmount)\n            ])\n        else {\n            let previousBidderAddr = addressFromStringValue(value(winner))\n            let priceAsset = if (priceAssetId == \"WAVES\" || priceAssetId == \"\") then unit else fromBase58String(priceAssetId)\n            ScriptResult(\n                WriteSet([\n                    DataEntry(auctionId + \"_winner\", callerAddressStr),\n                    DataEntry(auctionId + \"_winAmount\", totalBidAmount)\n                ]),\n                TransferSet([\n                    ScriptTransfer(previousBidderAddr, value(winAmount), priceAsset)\n                ])\n            )\n        }\n\n}\n\n\n@Callable(i)\nfunc withdraw(auctionId: String) = {\n\n    let pmt = extract(i.payment)    \n    let pmtAssetIdStr = if (isDefined(pmt.assetId)) then toBase58String(value(pmt.assetId)) else \"WAVES\"\n    let callerAddressStr = i.caller.bytes.toBase58String()\n\n    let endHeight = getIntegerValue(this, auctionId)\n    let organizer = getStringValue(this, auctionId + \"_organizer\")\n    let winner = getString(this, auctionId + \"_winner\")\n    let lotAssetId = getStringValue(this, auctionId + \"_lot_assetId\")\n    let lotAmount = getIntegerValue(this, auctionId + \"_lot_amount\")\n    let priceAssetId = getStringValue(this, auctionId + \"_priceAssetId\")\n    let winAmount = getIntegerValue(this, auctionId + \"_winAmount\")\n    \n    let lotAsset = if (lotAssetId == \"WAVES\") then unit else fromBase58String(lotAssetId)\n    let priceAsset = if (priceAssetId == \"WAVES\" || priceAssetId == \"\") then unit else fromBase58String(priceAssetId)\n    let winnerAddr = addressFromStringValue(value(winner))\n    let organizerAddr = addressFromStringValue(value(organizer))\n\n    let betAmount = getInteger(this, auctionId + \"_bidder_\" + callerAddressStr)\n\n    if (lastBlock.height < endHeight) then \n        throw(\"Auction is not finished yet\") else\n    \n    if (!isDefined(winner)) then {\n        if (isDefined(getString(this, auctionId + \"_lot_passed\"))) then\n            throw(\"Organizer has already got his lot back\")\n        else\n            ScriptResult(\n                WriteSet([DataEntry(auctionId + \"_lot_passed\", organizer)]),\n                TransferSet([ScriptTransfer(organizerAddr, lotAmount, lotAsset)])\n            )\n    }\n    else {\n        # Lot -> winner, winner's bet -> organizer\n        if (isDefined(getString(this, auctionId + \"_lot_passed\"))) then\n            throw(\"Lot is already passed to the winner, and organizer got his reward\")\n        else\n            ScriptResult(\n                WriteSet([DataEntry(auctionId + \"_lot_passed\", winnerAddr.bytes.toBase58String())]),\n                TransferSet([ScriptTransfer(winnerAddr, lotAmount, lotAsset),\n                            ScriptTransfer(organizerAddr, winAmount, priceAsset)])\n            )\n    }\n}\n","type":"ride","id":"auction/ride/auction.ride","sha":"53614d99cd92b9e606f01e2c497c6a1a570ebc70","readonly":true}]},{"name":"test","sha":"6adc031ed015b070b640363310c9bbfb5610103b","content":[{"name":"auction_test.js","content":"const auctionDuration = 2\n\nconst WAVES = 10 ** 8;\n\nconst SETSCRIPT_FEE = 0.01 * WAVES\nconst ISSUE_FEE = 1 * WAVES\nconst INV_FEE = 0.005 * WAVES\nconst ADD_FEE = 0.004 * WAVES\n\nvar issueTxId\nvar auctionId\nvar auctionStartTx\nvar customer2Before\n\nasync function rememberBalances(text, forAddress, tokenId) {\n    const tokenBal = await assetBalance(tokenId, forAddress)\n    const wavesBal = await balance(forAddress)\n\n    console.log (text + \": \" + wavesBal + \" WAVES, \" + tokenBal + \" NFT\")\n\n    return [wavesBal, tokenBal]\n}\n\n\ndescribe('Auction test Suite', async function(){\n    \n    this.timeout(100000)\n    \n    before(async function () {\n        await setupAccounts({auction: SETSCRIPT_FEE, customer1: ISSUE_FEE + 2*INV_FEE, customer2: (0.1 + 0.2 + 0.3) * WAVES, customer3: (0.22) * WAVES});\n\n        const compiledDApp = compile(file('auction.ride'))\n        const ssTx = setScript({script:compiledDApp/*, fee:1400000*/}, accounts.auction )\n        await broadcast(ssTx)\n\n        const issueTx = issue({name:\"MyNFTtest\", description:\"\", quantity:1, decimals:0, reissuable:false}, accounts.customer1)\n        await broadcast(issueTx)\n        await waitForTx(issueTx.id)\n        issueTxId = issueTx.id\n        console.log(\"NFT Token id: \" + issueTxId)\n        await waitForTx(ssTx.id)\n\n    })\n \n    it('Customer1: Start Auction', async function(){\n        const invTx = invokeScript({fee:INV_FEE, \n            dApp: address(accounts.auction),\n            call: {\n                function:\"startAuction\",\n                args:[\n                    {type:\"integer\", value: auctionDuration}, \n                    {type:\"integer\", value: 1000000}, \n                    {type:\"string\", value: \"WAVES\"}\n                ]}, \n                payment: [\n                    {amount: 1, assetId:issueTxId }\n                ]\n            }, accounts.customer1)\n\n        await broadcast(invTx)\n        auctionStartTx = await waitForTx(invTx.id)\n        auctionId = auctionStartTx.id\n\n        console.log(\"Start auction height : \" + auctionStartTx.height)\n    })\n\n    it('Unable to bid less then start price', async function(){\n        const invTx = invokeScript({fee:INV_FEE, dApp: address(accounts.auction), call: {function:\"bid\", args:[{type:\"string\", value: auctionId}]}, \n                        payment: [{amount: 999999, assetId:null }]}, \n                        accounts.customer2)\n        expect(broadcast(invTx)).rejectedWith(\"Bid must be more then 1000000\")\n    })\n    \n    it('Customer2: bid 0.1 WAVES', async function(){\n\n        customer2Before = await balance(address(accounts.customer2))\n\n        const invTx = invokeScript({fee:INV_FEE, dApp: address(accounts.auction), call: {function:\"bid\", args:[{type:\"string\", value: auctionId}]}, \n                        payment: [{amount: 10000000, assetId:null }]}, \n                        accounts.customer2)\n        await broadcast(invTx)\n        await waitForTx(invTx.id)\n    })\n\n    it('Customer3: bid 0.1 WAVES - should fail', async function(){\n        const invTx = invokeScript({fee:INV_FEE, dApp: address(accounts.auction), call: {function:\"bid\", args:[{type:\"string\", value: auctionId}]}, \n                        payment: [{amount: 10000000, assetId:null }]}, \n                        accounts.customer3)\n        expect(broadcast(invTx)).rejectedWith(\"Bid must be more then 10000000\")\n    })\n\n    it('Customer3: bid 0.2 WAVES - now should work', async function(){\n        const invTx = invokeScript({fee:INV_FEE, dApp: address(accounts.auction), call: {function:\"bid\", args:[{type:\"string\", value: auctionId}]}, \n                        payment: [{amount: 20000000, assetId:null }]}, \n                        accounts.customer3)\n        const resp = await broadcast(invTx)\n        await waitForTx(invTx.id)\n    })\n\n    it('Previous bid returned to bidder', async function(){\n        const customer2After = await balance(address(accounts.customer2))\n        expect(customer2After).to.equal(customer2Before - INV_FEE, \"Bid must be returned\")\n    })    \n   \n    it('Wait for auction end', async function(){\n        const timeout = 180000\n\t    this.timeout(timeout)\n        console.log(\"Cur height: \" + await currentHeight())\n        console.log(\"Waiting \" + (auctionStartTx.height + auctionDuration))\n        await waitForHeight(auctionStartTx.height + auctionDuration, {timeout})//waitForTxWithNConfirmations(auctionStartTx, auctionDuration, {timeout})\n    })\n\n    it('Customer2: bid 0.3 WAVES after acution end - should fail', async function(){\n        const invTx = invokeScript({fee:INV_FEE, dApp: address(accounts.auction), call: {function:\"bid\", args:[{type:\"string\", value: auctionId}]}, \n                        payment: [{amount: 30000000, assetId:null }]}, \n                        accounts.customer2)\n        expect(broadcast(invTx)).rejectedWith(\"Auction already finished\")\n    })\n\n    it('Customer3: Winner take prize', async function(){\n        \n        console.log(\"Cur height: \" + await currentHeight())\n\n        const winAmount = 20000000\n        \n        const nftBalBefore = await assetBalance(issueTxId, address(accounts.customer3))\n        const wavesBalanceBefore = await balance(address(accounts.customer1))\n        \n        const winnerBefore = await rememberBalances(\"Customer3 (winner): \", address(accounts.customer3), issueTxId)\n        const organizerBefore = await rememberBalances(\"Customer1 (organizer): \", address(accounts.customer1), issueTxId)\n\n        const invTx = invokeScript({fee:INV_FEE, dApp: address(accounts.auction), call: {function:\"withdraw\", args:[{type:\"string\", value: auctionId}]}, \n                        payment: []}, \n                        accounts.customer3)\n        await broadcast(invTx)\n        await waitForTx(invTx.id)\n        console.log(\"withdraw tx sent\")\n\n        const winnerAfter = await rememberBalances(\"Customer3 (winner): \", address(accounts.customer3), issueTxId)\n        const organizerAfter = await rememberBalances(\"Customer1 (organizer): \", address(accounts.customer1), issueTxId)\n\n        expect(winnerAfter[0]).to.equal(winnerBefore[0] - INV_FEE, \"WAVES Balance of winner is reduced only by fee\")\n        expect(winnerAfter[1]).to.equal(winnerBefore[1] + 1, \"Winner get's his auction prize\")\n\n    })\n})","type":"js","id":"auction/test/auction_test.js","sha":"3ba783d2a43faadfb01977827676dc10af31e180","readonly":true}]}]},{"name":"casino","sha":"2c54926c01f5e6c10ed0ddd660b4e451e5698d0d","content":[{"name":"readme.md","content":"# Casino\n\nThis is an implementation of the Casino with new RIDE features, so called ride 4 dapps\n\n## Oracle \n\nYou need an oracle which will provide results for the round\nOracle must provide the result in the following form\nroundKey -> result\nwhere roundKey is a string identifying the round, and result is a string in which:\n  character 0..1   - represent winning number\n  character 2 \t\t- represents winning red|black \n  character 3\t\t- represents winiing even|odd\n  character 4\t\t- represents winning half of the desk \n  character 5 \t\t- represents winning third of the desk \n  character 6\t\t- represents winning row of the desk\n\n## Making bet\n\nTo participate you need to invoke 'bet' function with \n\tstring argument identifying the round which you want to participate\n\tint argument identifying type of the bet (0 - number, 1 - red|black, 2 - even|odd ...)\n \tint argument representing you guess according to the bet type \n  And you need to put not less than 0.5 Waves to the call - it's your bet\n You can make multiple invokes of the 'bet' function for the same round\n\n After the oracle put stop mark for the round (data transaction with key <Round_id>_stop)\n you can not make bets for this round anymore.\n\n## Getting your prize if you win\n After the oracle put result you can invoke 'withdraw' function with \n\tstring argument identifying the round \n The function will send all money you won ","type":"md","id":"casino/readme.md","sha":"b2e770f95cd408f88969b53cafde57cc439e83c6","readonly":true},{"name":"ride","sha":"5ac001810f3b07a39c44a262b1e6603136456cc8","content":[{"name":"casino.ride","content":"{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet oracle = extract(addressFromString(\"$ORACLE_ADDRESS\"))\nlet minBet = \t  50000000\nlet maxSumBet = 1000000000 # max sum bet for round\n\nfunc calcWinAmount(this: Address|Alias, key: String, koeff: Int) = {\n\n    match getInteger(this, key) {\n        case a: Int => a * koeff\n        case _ => 0\n    }\n}\n\n@Callable(i)\nfunc bet(round: String, guessType: Int, guessValue: Int) = {\n\n   let pmt = extract(i.payment)\n\n   if (isDefined(pmt.assetId)) then \n    throw(\"Bets only in Waves supported\")\n   else if (pmt.amount < minBet) then\n    throw(\"Your Bet amount is less then minimal bet \" + toString(minBet))\n   else if (isDefined(getBoolean(oracle, round + \"_stop\")) || isDefined(getString(oracle, round))) then\n    throw(\"This round is already played\")\n   else {\n        let roundBetsKey = round + \"_sumBets\"\n        let curSumBets = match getInteger(this, roundBetsKey) {\n            case a:Int => a\n            case _ => 0\n        }\n        let newSumBets = curSumBets + pmt.amount\n\n        if (newSumBets > maxSumBet) then \n            throw(\"Maximum amount of bets for round \" + toString(maxSumBet) + \". With your bet it's \" + toString(newSumBets))\n        else\n        {\n            let betKey = toBase58String(i.caller.bytes) + \"_\" + round\n                            + \"_\" + toString(guessType) + \"_\" + toString(guessValue)\n            let curBetAmount = match getInteger(this, betKey) {\n                case a:Int => a\n                case _ => 0\n            }\n            let newBetAmount = curBetAmount + pmt.amount\n\n            WriteSet([  DataEntry(betKey, newBetAmount), \n                        DataEntry(roundBetsKey, newSumBets)])\n        }\n   }\n}\n\n@Callable(i)\nfunc withdraw(round: String) = {\n    let betKeyPart = toBase58String(i.caller.bytes) + \"_\" + round\n    let withdrawKey = betKeyPart + \"_withdraw\"\n\n    if (isDefined(getInteger(this, withdrawKey))) then {\n        throw(\"You have already got your prize\")\n        #WriteSet([])        \n    }\n    else\n    {\n        let valComplex = getStringValue(oracle, round)\n\n        let winNum = parseIntValue(drop(take(valComplex, 2), 0))\n        let winRedBlack = parseIntValue(drop(take(valComplex, 3), 2))\n        let winEvenOdd = parseIntValue(drop(take(valComplex, 4), 3))\n        let winDeskHalf = parseIntValue(drop(take(valComplex, 5), 4))\n        let winDeskThird = parseIntValue(drop(take(valComplex, 6), 5))\n        let winRow = parseIntValue(drop(take(valComplex, 7), 6))\n\n\n        let winAmount = calcWinAmount(this, betKeyPart + \"_0_\" + toString(winNum), 36) + \n                        calcWinAmount(this, betKeyPart + \"_1_\" + toString(winRedBlack), 2) + \n                        calcWinAmount(this, betKeyPart + \"_2_\" + toString(winEvenOdd), 2) + \n                        calcWinAmount(this, betKeyPart + \"_3_\" + toString(winDeskHalf), 2) + \n                        calcWinAmount(this, betKeyPart + \"_4_\" + toString(winDeskThird), 3) + \n                        calcWinAmount(this, betKeyPart + \"_5_\" + toString(winRow), 3) \n\n        if (winAmount == 0) then\n            throw(\"You won nothing this round\")\n        else\n            ScriptResult(\n                        WriteSet([DataEntry(withdrawKey, winAmount)]),\n                        TransferSet([ScriptTransfer(i.caller, winAmount, unit)])\n                    )\n    }\n}\n\n\n@Verifier(tx)\nfunc verify() = {\n    sigVerify(tx.bodyBytes, tx.proofs[0], base58'FYCT9GxhR2igEeyf9SWGi85bebBVaTAf9WUihEQnnBa9')\n    #true\n}","type":"ride","id":"casino/ride/casino.ride","sha":"cc0303916efbbe158ae86c0a0234e3088a0ce31b","readonly":true}]},{"name":"test","sha":"96a18197382ae8c789024fa35ab35e1135db9219","content":[{"name":"casino_test.js","content":"// ATTENTION: Tests can work incorrectly if you use nodes with cashed requests for balances\n// It could happen that 'nodes-testnet.wavesnodes.com' has that kind of cache\n\nconst WAVES = 10 ** 8;\n\nconst SETSCRIPT_FEE = 0.01 * WAVES\nconst ISSUE_FEE = 1 * WAVES\nconst INV_FEE = 0.005 * WAVES\nconst ADD_FEE = 0.004 * WAVES\nconst MIN_FEE = 0.001 * WAVES\n\nconst BET_TYPE_NUMBER = 0\nconst BET_TYPE_RED_BLACK = 1\nconst BET_TYPE_EVEN_ODD = 2\nconst BET_TYPE_DESK_HALF = 3\nconst BET_TYPE_DESK_THIRD = 4\nconst BET_TYPE_ROW = 5\n\nconst betAmount = 1.5 * WAVES\n\nasync function rememberBalances(text, forAddress) {\n    const wavesBal = await balance(forAddress)\n\n    console.log (text + \": \" + wavesBal + \" WAVES\")\n\n    return wavesBal\n}\n\nfunction makeBet(casinoPubKey, roundId, betAmount, betType, guess, playerPubKey) {\n\n    const bet = invokeScript({fee:INV_FEE, dApp: address(casinoPubKey), \n        call: {function:\"bet\", args:[{type:\"string\", value: roundId}, {type:\"integer\", value: betType}, {type:\"integer\", value: guess}]}, \n        payment: [{amount: betAmount, assetId:null }]}, \n        playerPubKey)\n\n    console.log(\"Bet. round: '\" + roundId + \"', amount: \" + betAmount / 10 ** 8 + \", betType: \" + betType + \", guess: '\" + guess + \"'\")\n    return bet\n}\n\nfunction withdraw(casinoPubKey, roundId, playerPubKey) {\n\n    const withdrawTx = invokeScript({fee:INV_FEE, dApp: address(casinoPubKey), \n        call: {function:\"withdraw\", args:[{type:\"string\", value: roundId}]}, \n        payment: []}, \n        playerPubKey)\n\n    return withdrawTx\n}\n\nasync function oracleStopRound(oraclePublicKey, roundId) {\n\n    const stopRound = data({data:[{key:roundId + '_stop', value:true, type: 'boolean'}]}, oraclePublicKey)\n\n    await broadcast(stopRound)\n    await waitForTx(stopRound.id)\n    console.log(\"Stop round: \" + roundId)\n}\n\nfunc makeOracleResultForNumber() {\n    const s = \"0\" + theAnswer\n    // TODO:\n    // Currently emulating just bet on number. These \"12345\" digits must be calculated in other way\n    // \"1\" must be changed to black/red indication\n    // \"2\" must be changed to even/odd indication\n    // etc.\n    return s.substr(s.length - 2) + \"12345\"\n}\n\nasync function oraclePublishCorrectAnswer(oraclePublicKey, roundId, theAnswer) {\n\n    const answerStr = makeOracleResultForNumber(theAnswer)\n\n    const oraclePublishAnswer = data({data:[{key:roundId, value:answerStr, type: 'string'}]}, oraclePublicKey)\n\n    await broadcast(oraclePublishAnswer)\n    await waitForTx(oraclePublishAnswer.id)\n    console.log(\"Published result for round '\" + roundId + \"': \" + answerStr)\n}\n\n\ndescribe('Casino script test suite', async function () {\n\n    this.timeout(100000);\n\n    before(async function () {\n\n        await setupAccounts({casino: SETSCRIPT_FEE + 35 * betAmount, \n                             player1: 2*betAmount + 2*INV_FEE, \n                            player2: betAmount + 2*INV_FEE, \n                            player3: betAmount + 2*INV_FEE, \n                            oracle: 2 * INV_FEE});\n        \n        const scriptC = compile(file('casino.ride').replace('$ORACLE_ADDRESS', address(accounts.oracle)));\n        const ssTx = setScript({script:scriptC}, accounts.casino);\n        await broadcast(ssTx);\n        await waitForTx(ssTx.id)\n        console.log('Script has been set')\n    });    \n\n    const roundId = \"Round 1\"\n    const correctAnswer = 12\n\n    it('Making bets', async function(){\n        \n        const bet1 = makeBet(accounts.casino, roundId, betAmount, BET_TYPE_NUMBER, 11, accounts.player1)\n        await broadcast(bet1)\n        const bet2 = makeBet(accounts.casino, roundId, betAmount, BET_TYPE_NUMBER, 10, accounts.player2)\n        await broadcast(bet2)\n        const bet3 = makeBet(accounts.casino, roundId, betAmount, BET_TYPE_NUMBER, correctAnswer, accounts.player3)\n        await broadcast(bet3)\n\n        await waitForTx(bet1.id)\n        await waitForTx(bet2.id)\n        await waitForTx(bet3.id)\n    })\n\n    it('Inability to make bet after freeze round', async function(){\n\n        await oracleStopRound(accounts.oracle, roundId)\n        \n        const bet1 = makeBet(accounts.casino, roundId, betAmount, BET_TYPE_NUMBER, 14, accounts.player1)\n        await expect(broadcast(bet1)).rejectedWith(\"This round is already played\")\n        console.log(\"Bet must failed because round finished\")        \n    })\n\n    it('Withdraw test', async function(){\n\n        await oraclePublishCorrectAnswer(accounts.oracle, roundId, correctAnswer)\n        \n        const withdraw1 = withdraw(accounts.casino, roundId, accounts.player1) \n        const withdraw2 = withdraw(accounts.casino, roundId, accounts.player2) \n        const withdraw3 = withdraw(accounts.casino, roundId, accounts.player3) \n\n        const casinoBefore = await rememberBalances(\"casino before: \", address(accounts.casino))\n        const winnerBefore = await rememberBalances(\"winner before: \", address(accounts.player3))\n\n        expect(broadcast(withdraw1)).rejectedWith(\"You won nothing this round\")\n        expect(broadcast(withdraw2)).rejectedWith(\"You won nothing this round\")\n        await broadcast(withdraw3)\n        await waitForTx(withdraw3.id)\n\n        const casinoAfter = await rememberBalances(\"casino after: \", address(accounts.casino))\n        const winnerAfter = await rememberBalances(\"winner after: \", address(accounts.player3))\n\n        expect(casinoAfter).to.equal(casinoBefore - 36 * betAmount, \"Casino account reduced by win amount\")\n        expect(winnerAfter).to.equal(winnerBefore + 36 * betAmount - INV_FEE, \"Winner account got win amount\")\n    })\n\n\n})\n","type":"js","id":"casino/test/casino_test.js","sha":"cea7fd959ea77207955504b693e472a8e660c004","readonly":true}]}]},{"name":"dApp-to-dApps","sha":"d4308eaa4197e4d82756a21745e26065e195dfca","content":[{"name":"add-pool-liquidity","sha":"1eb706306940bd3806134b949a80f5fa25ca990c","content":[{"name":"pool.ride","content":"# This is an example of a pool contract for add liquidity scenario.\n#\n# Increases pool liquidity using attached WAVES tokens for leasing and USDN tokens for staking.\n\n{-# STDLIB_VERSION 5     #-}\n{-# SCRIPT_TYPE ACCOUNT  #-}\n{-# CONTENT_TYPE DAPP    #-}\n\nlet usdN = base58''\nlet staker = Address(base58'')\nlet leasePool = Address(base58'')\nlet shareToken = base58''\n\n@Callable(i)\nfunc addLiquidity() = {\n  if (i.payments[0].assetId != unit || i.payments[1].assetId != usdN)\n    then\n      throw(\"unexpected assets\")\n    else {\n      strict r = invoke(staker, \"stake\", [], [i.payments[1]])\n      let stakingAmount = match r {\n        case a: Int => a\n        case _      => throw(\"unexpected result type from the staker\")\n      } \n        \n      let stakingAmountKey = \"STAKING_AMOUNT_\" + i.caller.toString()\n      let leaseAmountKey   = \"LEASE_AMOUNT_\" + i.caller.toString()\n      let idKey            = \"ID_\" + i.caller.toString()\n\n      let leasedAmount = this.getInteger(leaseAmountKey).valueOrElse(0)\n      let leaseId      = this.getString(idKey)\n\n      let newLease   = Lease(leasePool, leasedAmount + i.payments[0].amount)\n      let newLeaseId = calculateLeaseId(newLease)\n\n      let cancel = match leaseId {\n        case id: String => [ LeaseCancel(fromBase58String(id)) ]\n        case _          => [ StringEntry(idKey, toBase58String(newLeaseId)) ]\n      }\n\n      cancel ++\n      [\n        newLease,\n        ScriptTransfer(i.caller, 1, shareToken),\n        IntegerEntry(leaseAmountKey, leasedAmount + i.payments[0].amount),\n        IntegerEntry(stakingAmountKey, stakingAmount)\n      ]\n    }\n}\n","type":"ride","id":"dApp-to-dApps/add-pool-liquidity/pool.ride","sha":"bd0add721b6a84fca5ee0e611137854ba4160469","readonly":true},{"name":"staker.ride","content":"# This is an example of a staker contract for add liquidity scenario.\n#\n# Receives USDN and saves the new staking amount in the state.\n\n{-# STDLIB_VERSION 5     #-}\n{-# SCRIPT_TYPE ACCOUNT  #-}\n{-# CONTENT_TYPE DAPP    #-}\n\nlet usdN = base58''\n\n@Callable(i)\nfunc stake() = {\n  if (i.payments[0].assetId != usdN)\n    then\n      throw(\"unexpected asset\")\n    else {\n      let currentLiquidity = this.getInteger(i.originCaller.toString()).valueOrElse(0)\n      let newLiquidity = currentLiquidity + i.payments[0].amount\n      (\n        [ IntegerEntry(i.originCaller.toString(), newLiquidity) ],\n        newLiquidity\n      )\n    }\n}\n","type":"ride","id":"dApp-to-dApps/add-pool-liquidity/staker.ride","sha":"f2400701324733b81a09b2e5b29348c4d587c9bd","readonly":true}]},{"name":"flash-loan","sha":"7fb8c2eb20bb246c396a20d6dd1974e6933b85e6","content":[{"name":"borrower.ride","content":"# This is an example of a borrower contract for flash loan scenario.\n#\n# Borrows token A, changes to B, then changes the funds received again to A,\n# returns the money to the lender and stays in profit on token A.\n\n{-# STDLIB_VERSION 5     #-}\n{-# SCRIPT_TYPE ACCOUNT  #-}\n{-# CONTENT_TYPE DAPP    #-}\n\nlet loanFeePercent = 5\nlet assetA = base58''\nlet assetB = base58''\nlet exchangerABAddress = Address(base58'')\nlet exchangerBAAddress = Address(base58'')\nlet loanerAddress      = Address(base58'')\n\n@Callable(i)\nfunc trade(beneficiary: ByteVector) = {\n  let loanAmount =\n    if (i.payments[0].assetId == assetA)\n      then i.payments[0].amount\n      else throw(\"unexpected payment asset\")\n\n  strict startBalanceB = this.assetBalance(assetB)\n  strict r1 = invoke(exchangerABAddress, \"exchangeAB\", [], [AttachedPayment(assetA, loanAmount)])\n  strict diffB = this.assetBalance(assetB) - startBalanceB\n\n  strict r2 = invoke(exchangerBAAddress, \"exchangeBA\", [], [AttachedPayment(assetB, diffB)])\n\n  let debt = loanAmount.fraction(100 + loanFeePercent, 100)\n  let profit = this.assetBalance(assetA) - debt\n  [\n    ScriptTransfer(Address(beneficiary), profit, assetA),\n    ScriptTransfer(loanerAddress, debt, assetA)\n  ]\n}\n","type":"ride","id":"dApp-to-dApps/flash-loan/borrower.ride","sha":"ec08f44f453d8d29e67d4e9de48e117a2c8849a8","readonly":true},{"name":"exchanger1.ride","content":"# This is an example of a first exchanger contract for flash loan scenario.\n#\n# Changes A to B and transfers B to the address of the calling contract.\n# Returns transfer amount.\n\n{-# STDLIB_VERSION 5     #-}\n{-# SCRIPT_TYPE ACCOUNT  #-}\n{-# CONTENT_TYPE DAPP    #-}\n\nlet aToBRate = 5\nlet assetA = base58''\nlet assetB = base58''\n\n@Callable(i)\nfunc exchangeAB() = {\n  if (i.payments[0].assetId == assetA)\n    then\n      [ ScriptTransfer(i.caller, i.payments[0].amount * aToBRate, assetB) ]\n     else\n      throw(\"unexpected token\")\n}\n","type":"ride","id":"dApp-to-dApps/flash-loan/exchanger1.ride","sha":"ff37ea78bd7950901ae580184e575a101bf0ade1","readonly":true},{"name":"exchanger2.ride","content":"# This is an example of a second exchanger contract for flash loan scenario.\n#\n# Changes B to A and transfers A to the address of the calling contract.\n# Returns transfer amount.\n\n{-# STDLIB_VERSION 5     #-}\n{-# SCRIPT_TYPE ACCOUNT  #-}\n{-# CONTENT_TYPE DAPP    #-}\n\nlet exchangeRate = 5\nlet exchangeRateDiffPercent = 20\nlet aToBRate = exchangeRate.fraction(100 - exchangeRateDiffPercent, 100)\nlet assetA = base58''\nlet assetB = base58''\n\n@Callable(i)\nfunc exchangeBA() = {\n  if (i.payments[0].assetId == assetB)\n    then\n      [ ScriptTransfer(i.caller, i.payments[0].amount / aToBRate, assetA) ]\n     else\n      throw(\"unexpected token\")\n}\n","type":"ride","id":"dApp-to-dApps/flash-loan/exchanger2.ride","sha":"b4a2ec3d400366ac59b47b0bbe3318fbe2416af0","readonly":true},{"name":"loaner.ride","content":"# This is an example of a loaner contract for flash loan scenario.\n#\n# Should be called from the account related to the borrower.\n#\n# Calls the contract specified by the borrower when called in the transaction\n# and applies the requested amount of token A in the call.\n# Checks that upon completion of the call to the contract, the balance of token A has increased.\n\n{-# STDLIB_VERSION 5     #-}\n{-# SCRIPT_TYPE ACCOUNT  #-}\n{-# CONTENT_TYPE DAPP    #-}\n\nlet assetA = base58''\nlet loanFeePercent = 5\n\n@Callable(i)\nfunc loan(amount: Int, callback: String, borrower: ByteVector) = {\n  strict startBalance = this.assetBalance(assetA)\n  strict r = invoke(Address(borrower), callback, [i.caller.bytes], [AttachedPayment(assetA, amount)])\n\n  let balanceDiff = this.assetBalance(assetA) - startBalance\n  let profit      = amount.fraction(loanFeePercent, 100)\n\n  if (balanceDiff < profit)\n    then\n      throw(\"debt is not paid: diff=\" + balanceDiff.toString() + \", expected=\" + profit.toString())\n    else\n      []\n}\n","type":"ride","id":"dApp-to-dApps/flash-loan/loaner.ride","sha":"8ec98d31292fe09081229c8cf4ca839e024b2ed7","readonly":true}]},{"name":"swap","sha":"7725b7831f26cacc715cd6da1617f5e6858f2395","content":[{"name":"exchanger.ride","content":"# This is an example of a exchanger contract for swap scenario.\n#\n# Calls the USDN staking contract canceling USDN staking for the amount\n# that the user should receive during the exchange\n# and transfers USDN to the user's address.\n\n{-# STDLIB_VERSION 5     #-}\n{-# SCRIPT_TYPE ACCOUNT  #-}\n{-# CONTENT_TYPE DAPP    #-}\n\nlet usdN = base58''\nlet exchangeRate = 5\nlet staker = Address(base58'')\n\n@Callable(i)\nfunc exchangeWavesUsdN() = {\n  if (i.payments[0].assetId != unit)\n    then\n      throw(\"unexpected asset\")\n    else {\n      strict r = invoke(staker, \"cancelStake\", [i.payments[0].amount * exchangeRate], [])\n      [ ScriptTransfer(i.caller, i.payments[0].amount * exchangeRate, usdN) ]\n    }\n}\n","type":"ride","id":"dApp-to-dApps/swap/exchanger.ride","sha":"a392228b143d3c0bcf165866ce25fd953ab797db","readonly":true},{"name":"staker.ride","content":"# This is an example of a staker contract for swap scenario.\n#\n# \"stake\" receives USDN and saves the new staking amount in the state.\n# \"cancelStake\" withdraws the required amount from staking and transfers it to the account.\n\n{-# STDLIB_VERSION 5     #-}\n{-# SCRIPT_TYPE ACCOUNT  #-}\n{-# CONTENT_TYPE DAPP    #-}\n\nlet usdN = base58''\n\n@Callable(i)\nfunc stake() = {\n  if (i.payments[0].assetId != usdN)\n    then\n      throw(\"unexpected asset\")\n    else {\n      let currentLiquidity = this.getInteger(i.originCaller.toString()).valueOrElse(0)\n      [ IntegerEntry(i.originCaller.toString(), currentLiquidity + i.payments[0].amount) ]\n    }\n}\n\n@Callable(i)\nfunc cancelStake(amount: Int) = {\n  if (this.getIntegerValue(i.caller.toString()) >= amount)\n    then\n      [ ScriptTransfer(i.caller, amount, usdN) ]\n    else\n      throw(\"too big amount\")\n}\n","type":"ride","id":"dApp-to-dApps/swap/staker.ride","sha":"559b3862ce293634e55958d736b660bfc59ba12d","readonly":true}]}]},{"name":"dApps","sha":"765448518455e77ce4bf45106f8d3162e09a81c3","content":[{"name":"8ball","sha":"5a2f4886bd09199f47b164f2a95c7f79e76a0eaa","content":[{"name":"README.md","content":"# Waves Magic 8 Ball\n\nDon't know what to do?\nYou want an answer to THE question?\nMagic 8 Ball - it’s the fastest way to seek advice!\ndApp uses an innovative(not) method of pseudorandom answer generation to give you the best possible answer.\nAnd it also ensures that same question should get a different answer.\n\n### Deploying\n\n1. Compile RIDE script\n2. Deploy smart script to dApp account\n3. You ready to go!\n\n### How to use\n\n1. Prepare Invoke script TX with function name `tellme` and single argument: `question: string`\n2. Broadcast your TX\n3. Your question and answer should be written to dApp data state\n4. Question key: `yourb58address_q`\n5. Answer key: `yourb58address_a`\n\n### dApp on Testnet\n\nCode for [RIDE IDE](https://ide.wavesplatform.com/) console\n```JS\nconst question = \"Should i do that?\"\nconst invokeTX = invokeScript({ fee: 500000, dApp: \"3N27HUMt4ddx2X7foQwZRmpFzg5PSzLrUgU\", call:{function:\"tellme\",args:[{\"type\": \"string\", \"value\": question}]}, payment: null})\nbroadcast(invokeTX)\n```","type":"md","id":"dApps/8ball/README.md","sha":"92748568b007686766cb0b92ac4a767ad4e75a61","readonly":true},{"name":"ride","sha":"6116ce62cf2c2c19cd54c78134662ba39e6862e3","content":[{"name":"8ball.ride","content":"{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n#\n# Waves dApp version of famous Magic 8 ball toy!\n# Function name: tellme(question: String)\n# Question and answer will be written to dApp data state\n#\n# Example on Testnet: 3N27HUMt4ddx2X7foQwZRmpFzg5PSzLrUgU\n#\n\nlet answersCount = 20\nlet answers = \n    [\"It is certain.\",\n    \"It is decidedly so.\",\n    \"Without a doubt.\",\n    \"Yes - definitely.\",\n    \"You may rely on it.\",\n    \"As I see it, yes.\",\n    \"Most likely.\",\n    \"Outlook good.\",\n    \"Yes.\",\n    \"Signs point to yes.\",\n    \"Reply hazy, try again.\",\n    \"Ask again later.\",\n    \"Better not tell you now.\",\n    \"Cannot predict now.\",\n    \"Concentrate and ask again.\",\n    \"Don't count on it.\",\n    \"My reply is no.\",\n    \"My sources say no.\",\n    \"Outlook not so good.\",\n    \"Very doubtful.\"]\n\n\n#\n# Simple pseudorandom answer generator\n#\nfunc getAnswer(question: String, previousAnswer: String) = {\n    let hash = sha256(toBytes(question + previousAnswer))\n    let index = toInt(hash)\n    answers[index % answersCount]\n}\n\nfunc getPreviousAnswer(address: String) = {\n  match getString(this, address + \"_a\") {\n    case a: String => a\n    case _ => address\n  }\n}\n\n@Callable(i)\nfunc tellme(question: String) = {\n    let callerAddress = toBase58String(i.caller.bytes)\n    let answer = getAnswer(question, getPreviousAnswer(callerAddress))\n\n    WriteSet([\n        DataEntry(callerAddress + \"_q\", question),\n        DataEntry(callerAddress + \"_a\", answer)\n        ])\n}","type":"ride","id":"dApps/8ball/ride/8ball.ride","sha":"fb1eaee4f9abea218a5e33733f7770547a58e951","readonly":true}]},{"name":"tests","sha":"1a99ca340cb62401bbf3f3190a9344a3928ace36","content":[{"name":"8ball_test.js","content":"//\n// Waves dApp Magic 8 ball tests\n//\n\ndescribe('8 ball', () => {\n    const ballAddress = \"3N27HUMt4ddx2X7foQwZRmpFzg5PSzLrUgU\"\n    const question = \"Test\" + Date.now()\n    const tx = invokeScript({fee: 500000, dApp: ballAddress, call:{function:\"tellme\", args:[{\"type\": \"string\", \"value\": question}]}, payment: null})\n\n    it('Tx is mined in block', async function(){\n        await broadcast(tx)\n        await waitForTx(tx.id)\n    })\n\n    it('Question is in ball', async function(){\n        await accountDataByKey(address()+\"_q\", ballAddress)\n            .then(reslove => expect(reslove.value).to.equal(question))\n    })\n})","type":"js","id":"dApps/8ball/tests/8ball_test.js","sha":"686e31447b60798dca8c30472a9da276335e4519","readonly":true}]}]},{"name":"bankCredit","sha":"e9ed51c48997e159d969decfe48d7b4592fab1df","content":[{"name":"README.md","content":"# Bank credit dApp\nWe assume that customer account have some value by itself\n#### E.g: \n* Account could control another dapp\n* It is tied to his passport via government service\n* Owning an account provides ownership of some real world thing\n* Customer completed some complex KYC with this account on third party service\n\n## Workflow \n1. Bank approves credit for some address via `approveCredit` function. It defines client address, amount of money, target height to return and account script for client.\n2. Customer sets `lock script` fon his account.\n3. Customer can get money if he provides proof, that script was indeed set on his account\n4. Customer can cancel credit contract via 'cancelCredit' if he didn't take the money\n5. Customer can return money via 'returnMoney' function\n\n## Simplifications for this version:\na) This version does not account interest, but it can be easily added via additional argument to 'approveCredit'\nb) This version does not separate different credit contracts for one account. For now it is possible to have only one. Having multiple contracts can also be implemented with contract id's\n\n## Account lock script:\nCustomer sets account script, which forbids setting another account script. After target height script forbids any operations other than calling dApp functions. If contract status is in `[\"returned\", \"canceled\"]`, script allows to unset itself\n","type":"md","id":"dApps/bankCredit/README.md","sha":"2d56b8f796fb09013dc5e138dbff2e4ac0e8cdcf","readonly":true},{"name":"ride","sha":"40762ed42c0300e7b838a596ce5e6a23fb35c586","content":[{"name":"account_lock.ride","content":"# This is LOCK script. Customer has to set this script to his account to be able to get money from the bank\n\n{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n# Bank dApp address\nlet BANK = base58'3MpFRn3X9ZqcLimFoqNeZwPBnwP7Br5Fmgs'\n\n\nlet TARGETHEIGHT = match( getInteger(Address(BANK), toBase58String(tx.sender.bytes) + \"_target\")){\n    case _: Unit => 0\n    case x: Int => x\n}\nlet status = match( getString(Address(BANK), toBase58String(tx.sender.bytes) + \"_status\")){\n    case _: Unit => \"unset\"\n    case x: String => x\n}\n\n# If it is time to pay and money has been borrowed and not returned, we only allow InvokeScript on bank dApp. Anyone can call this dapp\nif (height > TARGETHEIGHT && status == \"borrowed\") then {\n    match (tx){\n        case t: InvokeScriptTransaction => addressFromRecipient(t.dApp).bytes == BANK\n        case _ => false\n    }\n# Otherwise if returned allow all\n}else if(status == \"returned\" || status == \"canceled\") then {\n    sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)\n# In any other case forbid SetScript\n}else {\n    match (tx){\n        case _: SetScriptTransaction => false\n        case _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)\n    }\n}\n\n\n","type":"ride","id":"dApps/bankCredit/ride/account_lock.ride","sha":"a39bfd03cd706229f1e80f3ff454f19a95fef5f6","readonly":true},{"name":"bank_dapp.ride","content":"{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n@Callable(i)\nfunc approveCredit(client: String, amount: Int, target: Int, lockHash: ByteVector) = {\n    if (this == i.caller && !isDefined(getBoolean(this, client + \"_status\"))) then {\n        WriteSet([\n            DataEntry(client + \"_status\", \"approved\"),\n            DataEntry(client + \"_amount\", amount),\n            DataEntry(client + \"_target\", target),\n            DataEntry(client + \"_lockScriptId\", lockHash)\n        ])\n    }else {\n        throw(\"Credit for \" + client + \" has already been approved or caller is not dApp owner\")\n    }\n\n}\n\n@Callable(i)\nfunc getMoney() = {\n\n    let callerStr = toBase58String(i.caller.bytes)\n\n    let status = match( this.getString(callerStr + \"_status\")){\n        case _: Unit => \"unset\"\n        case x: String => x\n    }\n\n    let lockTxId = this.getString(callerStr + \"_lockScriptId\").extract()\n    let lockTx = transactionHeightById(fromBase58String(lockTxId))\n\n    let isLockSet = match (lockTx) {\n        case _: Int => true\n        case _ => throw(\"Lock has not been set\")\n    }\n\n    let amount = this.getInteger(callerStr + \"_amount\").extract()\n\n    if (status == \"approved\" && isLockSet) then {\n        ScriptResult(\n            WriteSet([\n                DataEntry(callerStr + \"_status\", \"borrowed\")\n            ]),\n            TransferSet([ScriptTransfer(i.caller, amount, unit)])\n        )\n    }else throw(\"Credit was not approved or money has already been taken\")\n\n}\n\n@Callable(i)\nfunc returnMoney() = {\n    let callerStr = toBase58String(i.caller.bytes)\n    let status = match( this.getString(callerStr + \"_status\")){\n        case _: Unit => \"unset\"\n        case x: String => x\n    }\n\n    let pmt = extract(i.payment)\n\n    let amountToReturn = getInteger(this, callerStr + \"_amount\")\n    if(status != \"borrowed\") then throw(\"Cannot return, nothing was borrowed\")\n    else if (isDefined(pmt.assetId)) then throw(\"Can return only WAVES at the moment\")\n    else if (amountToReturn != pmt.amount) then throw(\"Should return borrowed amount\")\n    else {\n        WriteSet([\n            DataEntry(callerStr + \"_status\", \"returned\")\n        ])\n    }\n}\n\n@Callable(i)\nfunc cancelContract() = {\n    let callerStr = toBase58String(i.caller.bytes)\n    let status = match( this.getString(callerStr + \"_status\")){\n        case _: Unit => \"unset\"\n        case x: String => x\n    }\n    if(status == \"approved\" || status == \"unset\") then WriteSet([DataEntry(callerStr + \"_status\", \"canceled\")])\n    else {throw(\"Cannot cancel credit. Money has already been taken\")}\n}\n\n@Verifier(tx)\nfunc verify() = {\n    match(tx) {\n        case _:DataTransaction => false\n        case _:SetScriptTransaction => false\n        case _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)\n    }\n}\n","type":"ride","id":"dApps/bankCredit/ride/bank_dapp.ride","sha":"dd381771c5c1536e072c24e8a2a5e0b46951804a","readonly":true}]},{"name":"test","sha":"30f00a8b0e3dd62cd728ba284cd72d1453ff0c64","content":[{"name":"test.js","content":"const wvs = 10 ** 8;\n\ndescribe('Bank Dapp test Suite', () => {\n\n    let lockTx;\n    let removeLockTx;\n    let paymentAmount = 0.4 * wvs\n\n    before(async function() {\n        this.timeout(0);\n\n        await setupAccounts({bank: 0.5 * wvs, client: 0.1 * wvs});\n\n        const compiledDapp = compile(file('bank_dapp.ride'))\n        const bankAddress = address(accounts.bank)\n        const lockScript = file('account_lock.ride')\n            .replace(`base58'3MpFRn3X9ZqcLimFoqNeZwPBnwP7Br5Fmgs'`, `base58'${bankAddress}'`)\n\n        const compiledLock = compile(lockScript)\n\n        lockTx = setScript({script: compiledLock}, accounts.client)\n        removeLockTx = setScript({script: null, additionalFee: 400000}, accounts.client)\n        const dAppTx = setScript({script: compiledDapp}, accounts.bank)\n        await broadcast(dAppTx)\n        await waitForTx(dAppTx.id)\n        console.log('Scrips were deployed')\n    })\n\n    it('Bank approves credit for customer', async function(){\n        const invTx = invokeScript({\n            additionalFee: 400000,\n            dApp: address(accounts.bank),\n            call: {\n                function: \"approveCredit\",\n                args: [{\n                    type: \"string\",\n                    value: address(accounts.client)\n                }, {\n                    type: \"integer\",\n                    value: paymentAmount\n                }, {\n                    type: \"integer\",\n                    value: 0\n                }, {\n                    type: \"string\",\n                    value: lockTx.id\n                }]\n            }\n        }, accounts.bank)\n\n        await broadcast(invTx)\n        await waitForTx(invTx.id)\n    })\n\n    it('Customer fails to get money without lock', async function(){\n        const invTx = invokeScript({\n                additionalFee: 500000,\n                dApp: address(accounts.bank),\n                call: {\n                    function: \"getMoney\"\n                }\n            }, accounts.client)\n        await expect(broadcast(invTx)).rejectedWith()\n    })\n\n    it('Customer sets lock and gets money', async function(){\n        this.timeout(0)\n\n        await broadcast(lockTx)\n        await waitForTx(lockTx.id, {timeout: 1000000})\n\n        const invTx = invokeScript({\n            additionalFee: 500000,\n            dApp: address(accounts.bank),\n            call: {\n                function: \"getMoney\"\n            }\n        }, accounts.client)\n        await broadcast(invTx)\n        await waitForTx(invTx.id, {timeout: 1000000})\n    })\n\n    it('Customer fails to remove lock', async function(){\n        await expect(broadcast(removeLockTx)).rejectedWith()\n    })\n\n    it('Customer returns money and removes lock from his account', async function(){\n        this.timeout(0)\n        const invTx = invokeScript({\n            additionalFee: 500000,\n            dApp: address(accounts.bank),\n            call: {\n                function: \"returnMoney\",\n                args: []\n            },\n            payment:[{\n                amount: paymentAmount\n            }]\n        }, accounts.client)\n        await broadcast(invTx);\n        await waitForTx(invTx.id, {timeout: 1000000});\n        await broadcast(removeLockTx)\n    })\n})\n\n\n","type":"js","id":"dApps/bankCredit/test/test.js","sha":"e718c84b6769b38b4cec51a617172458aa021d6e","readonly":true}]}]},{"name":"fomo.ride","content":"{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet lpKey = \"lastPayment\"\nlet liKey = \"bestFomoer\"\nlet lhKey = \"height\"\nlet day = 1440\n\n@Callable(i)\nfunc fearmissing() = {\n   let payment = match i.payment {\n\t   case p:AttachedPayment =>\n\t   \t\tmatch p.assetId  {\n\t\t\t\t   case assetId: ByteVector => throw(\"fomo waves only\")\n\t\t\t\t   case _ => p.amount\n\t\t\t   }\n\n\t   case _ => throw(\"payment must be attached\")\n   }\n\tlet lastPayment = match getInteger(this, \"lastPayment\") {\n\t\tcase p:Int => p\n\t\tcase _ => 0\n\t}\n\n\tif(payment <= lastPayment)\n\t\tthen throw(\"min payment is \" +toString(payment))\n\t\telse # storing best payment, caller and height\n\t\t\tWriteSet([\n\t\t\t\tDataEntry(lpKey, payment),\n\t\t\t\tDataEntry(liKey, i.caller.bytes),\n\t\t\t\tDataEntry(lhKey, height)\n\t\t\t])\n}\n\n@Callable(i)\nfunc withdraw() = {\n\tlet callerCorrect = i.caller.bytes == extract(getBinary(this, liKey))\n\tlet heightCorrect = extract(getInteger(this, lhKey)) - height >= day\n\tlet canWithdraw = heightCorrect && callerCorrect\n\n\tif (canWithdraw)\n\t\tthen TransferSet([ScriptTransfer(i.caller, wavesBalance(this), unit)])\n\t\telse throw(\"behold\")\n}\n","type":"ride","id":"dApps/fomo.ride","sha":"65fd9ab026daa2444b208f348cb4ac4f53c8f944","readonly":true},{"name":"momentaryLottery","sha":"2ac78350d1e031e5e462d2bba0bd75cf4e4392ab","content":[{"name":"README.md","content":"# Momentary Lottery dApp\n\nMomentary Lottery fully on blockchain\nWin chance is 50/50 with pay rate 1.9x\n\n### Deploying\n\n1. Compile RIDE script\n2. Deploy smart script to dApp account\n3. You are ready to go!\n\n### How to use\n\n1. Prepare Invoke script TX with function name `lotto` or Default function with payment in Waves\n2. Broadcast your TX\n3. dApp will resolve bet and transfer you winning amount or nothing (tough luck)\n\n\n### dApp on Testnet\n\nCode for [RIDE IDE](https://ide.wavesplatform.com/) console\n```JS\nconst betAmount = 1000000\nconst invokeTX = invokeScript({ fee: 500000, dApp: \"3Mu5kasZ85VY5xUCpPYoWr6fBzh6eGZwcnt\", call: null, payment: [{assetId: null, amount: 1000000}]})\nbroadcast(invokeTX)\n```","type":"md","id":"dApps/momentaryLottery/README.md","sha":"27018acd03667fc9c15d3ecc32daf255df50dd39","readonly":true},{"name":"ride","sha":"7f6ab2bb039350a3cc89267232e641a4f896f387","content":[{"name":"momentaryLottery.ride","content":"{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n#\n# Momentary Lottery fully on blockchain.\n# Win chance is 50/50 with pay rate 1.9x\n# Function name: lotto() or Default function\n# Payment: Any amount in Waves\n#\n# Example on Testnet: 3Mu5kasZ85VY5xUCpPYoWr6fBzh6eGZwcnt\n#\n\n\n#\n# Pseudorandom generator fully based on blockchain state\n#\nfunc randomizer(inv: Invocation) = {\n    let lastPlay = match getBinary(this, \"lastPlay\") {\n        case s:ByteVector => s\n        case _:Unit => base64'V2F2ZXNMb3R0b1Yy'\n    }\n\n    let rand = lastPlay + inv.transactionId + inv.callerPublicKey + lastBlock.generationSignature + toBytes(lastBlock.timestamp) + toBytes(lastBlock.height)\n    sha256(rand)\n}\n\nfunc startLotto(inv: Invocation) = {\n    let playLimit = wavesBalance(this) / 100\n    let payment = extract(inv.payment)\n\n    if(!isDefined(inv.payment)) then {\n        throw(\"Should be with Payment in Waves\")\n    } else if (isDefined(payment.assetId)) then {\n        throw(\"Payment should be in Waves\")\n    } else if (payment.amount > playLimit) then {\n        throw(\"Payment should be less than \" + toString(playLimit))\n    } else {\n\n        let randhash = randomizer(inv)\n        let winTransfer = TransferSet([ScriptTransfer(inv.caller, payment.amount * 190 / 100, unit)])\n        let writeLastPlay = WriteSet([DataEntry(\"lastPlay\", randhash)])\n\n        if(randhash.toInt() % 1000 < 500) then {\n            ScriptResult(writeLastPlay, winTransfer)\n        } else {\n            ScriptResult(writeLastPlay, TransferSet([]))\n        }\n    }\n}\n\n@Callable(inv)\nfunc lotto() = {\n    startLotto(inv)\n}\n\n@Callable(inv)\nfunc default() = {\n    startLotto(inv)\n}\n","type":"ride","id":"dApps/momentaryLottery/ride/momentaryLottery.ride","sha":"d0863ef850b6bd0cb31703c967e290e5f6731871","readonly":true}]},{"name":"test","sha":"0bf7fff40170654426a477c386f951452f087b5e","content":[{"name":"momentaryLottery_test.js","content":"//\n// Momentary Lottery tests\n// Tests will run from current IDE account\n// Account should have at lease 5 Waves and at least 0.01 non Waves tokens\n//\n\ndescribe('Momentary Lotto', () => {\n    const lottoAddress = \"3Mu5kasZ85VY5xUCpPYoWr6fBzh6eGZwcnt\"\n    const someAssetId = \"CJDViFTTV5gmR6Kb1xVtwNUb9fkSgjeWrsCRZWQkG8t6\" //Should be on test account balance\n    const betAmount = 1000000\n\n    it('Play with function name', async function(){\n        const tx = invokeScript({ fee: 500000, dApp: lottoAddress, call: {function: \"lotto\", args: []}, payment: [{assetId: null, amount: betAmount}]})\n        await broadcast(tx)\n        await waitForTx(tx.id)\n    })\n\n    it('Play with default function', async function(){\n        const tx = invokeScript({ fee: 500000, dApp: lottoAddress, call: null, payment: [{assetId: null, amount: betAmount}]})\n        await broadcast(tx)\n        await waitForTx(tx.id)\n    })\n\n    it('Without payment', async function(){\n        const tx = invokeScript({ fee: 500000, dApp: lottoAddress, call: null, payment: []})\n        return expect(broadcast(tx)).to.eventually\n            .be.rejectedWith(\"Should be with Payment in Waves\")\n    })\n\n    it('With payment not in Waves', async function(){\n        const tx = invokeScript({ fee: 500000, dApp: lottoAddress, call: null, payment: [{assetId: someAssetId, amount: betAmount}]})\n        return expect(broadcast(tx)).to.eventually\n            .be.rejectedWith(\"Payment should be in Waves\")\n    })\n\n    it('Bet amount is too large', async function(){\n        const lottoBalance = await balance(lottoAddress)\n        const bet = Math.trunc(lottoBalance / 10)\n        const tx = invokeScript({ fee: 500000, dApp: lottoAddress, call: null, payment: [{assetId: null, amount: bet}]})\n        return expect(broadcast(tx)).to.eventually\n            .be.rejectedWith(\"Payment should be less than\")\n    })\n})","type":"js","id":"dApps/momentaryLottery/test/momentaryLottery_test.js","sha":"17508c3f5a6070eb5cb1b7de4afd0b21d451d8a0","readonly":true}]}]},{"name":"wallet","sha":"007bc7b2f7652a59409d174f1532c97301c7c709","content":[{"name":"ride","sha":"d12ca77418d80f8e7fc30dd745d3573b40e25c31","content":[{"name":"wallet.ride","content":"# In this example multiple accounts can deposit their funds and safely take them back.\n# User balances are stored in the dApp state as mapping `address=>waves`.\n\n{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n@Callable(i)\nfunc deposit() = {\n   # deposit function can be invoked from UI by user to top up the balance\n   let pmt = extract(i.payment)  # creating variable with all data about a payment attached to the invokation\n   if (isDefined(pmt.assetId)) then throw(\"can hodl waves only at the moment\")  # waves-only threshold\n   else {\n        let currentKey = toBase58String(i.caller.bytes)  # determining caller key\n        let currentAmount = match getInteger(this, currentKey) {  # reading current user's balance from the account state\n            case a:Int => a\n            case _ => 0  # taking zero as a balance value if this is the first time user deposits money\n        }\n        let newAmount = currentAmount + pmt.amount  # counting new balance as \"old balance + payment value\"\n        WriteSet([DataEntry(currentKey, newAmount)])  # updating user's balance in the account state\n   }\n}\n\n@Callable(i)\nfunc withdraw(amount: Int) = {\n    # withdraw function can be invoked by user to \"cash out\" a part of his balance\n    let currentKey = toBase58String(i.caller.bytes) \n    let currentAmount = match getInteger(this, currentKey) {\n        case a:Int => a\n        case _ => 0\n    }\n    let newAmount = currentAmount - amount\n    if (amount < 0)  # is user requesting a positive amount?\n            then throw(\"Can't withdraw negative amount\")\n    else if (newAmount < 0)  # does user have enough balance for this withdraw?\n            then throw(\"Not enough balance\")\n            else ScriptResult(\n                    WriteSet([DataEntry(currentKey, newAmount)]),  # saving new balance to the account state\n                    TransferSet([ScriptTransfer(i.caller, amount, unit)])  # transfering the withdraw amount to user\n                )\n    }\n\n@Verifier(tx)\nfunc verify() = false  # this script can NOT be updated because of this verifier function\n\n\n","type":"ride","id":"dApps/wallet/ride/wallet.ride","sha":"07277389f9c571bc1deb00a3a896cf34f04499e4","readonly":true}]},{"name":"test","sha":"a1af145249aee29cd0c5907aeafe07209e0aeb89","content":[{"name":"wallet.js","content":"const wvs = 10 ** 8;\r\n\r\ndescribe('wallet test suite', async function () {\r\n\r\n    this.timeout(100000);\r\n\r\n    before(async function () {\r\n        await setupAccounts(\r\n            {foofoofoofoofoofoofoofoofoofoofoo: 10 * wvs,\r\n                 barbarbarbarbarbarbarbarbarbar: 2 * wvs,\r\n                  wallet: 0.05 * wvs});\r\n        const script = compile(file('wallet.ride'));\r\n        const ssTx = setScript({script}, accounts.wallet);\r\n        await broadcast(ssTx);\r\n        await waitForTx(ssTx.id)\r\n        console.log('Script has been set')\r\n    });\r\n    \r\n    it('Can deposit', async function () {\r\n\r\n        const iTxFoo = invokeScript({\r\n            dApp: address(accounts.wallet),\r\n            call: {function: \"deposit\"},\r\n            payment: [{assetId: null, amount: 0.9 * wvs}]\r\n        }, accounts.foofoofoofoofoofoofoofoofoofoofoo);\r\n\r\n\r\n        const iTxBar = invokeScript({\r\n            dApp: address(accounts.wallet),\r\n            call: {function: \"deposit\"},\r\n            payment: [{assetId: null, amount: 1.9 * wvs}]\r\n        }, accounts.barbarbarbarbarbarbarbarbarbar)\r\n\r\n\r\n        await broadcast(iTxFoo);\r\n        await broadcast(iTxBar);\r\n        await waitForTx(iTxFoo.id);\r\n        await waitForTx(iTxBar.id);\r\n    })\r\n\r\n    it('Cannot withdraw more than was deposited', async function () {\r\n        const iTxFoo = invokeScript({\r\n            dApp: address(accounts.wallet),\r\n            call: {\r\n                function: \"withdraw\",\r\n                args: [{type:'integer', value: 2 * wvs}]\r\n            },\r\n\r\n        }, accounts.foofoofoofoofoofoofoofoofoofoofoo);\r\n\r\n        expect(broadcast(iTxFoo)).to.be.rejectedWith(\"Not enough balance\")\r\n    })\r\n\r\n    it('Can withdraw', async function () {\r\n        const iTxFoo = invokeScript({\r\n            dApp: address(accounts.wallet),\r\n            call: {\r\n                function: \"withdraw\",\r\n                args: [{ type: 'integer', value: 0.9 * wvs }]\r\n            },\r\n\r\n        }, accounts.foofoofoofoofoofoofoofoofoofoofoo);\r\n        await broadcast(iTxFoo)\r\n    })\r\n})","type":"js","id":"dApps/wallet/test/wallet.js","sha":"332da465cdf367042249a588b05f8bf7b26d46f2","readonly":true}]}]}]},{"name":"smart-accounts","sha":"52cfd52a29a78e71064d0eb114c9a1d26c48fafb","content":[{"name":"AuthorizedTrader.ride","content":"#allow trader to set orders on your account\n#this is the same as you send your api-key on common exchanges to the trader without sharing your private key or seed\n#trader is allowed to set order on certain pairs\n#order expiration time should be less then 2 minutes, as trader cannot cancel orders in current RIDE version\n#at any time accout owner can cancel\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet traderPublicKey = base58'QLMkJYFXsXiLLiKCbVCZZzQQT3whz8PAPdT7w4yQjEn'\nlet ownerPublicKey = base58'4gFmmsNv1qA9Krn3pUGbZVcJQTCsXEXhZjEtszDtxMXz'\nlet amountAsset = base58'8LLpj6yQLUu37KUt3rVo1S69j2gWMbgbM6qqgt2ac1Vb'\nlet matcherPublicKey = base58'7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy'\n\n\nmatch (tx) {\n    case o:Order =>\n        let isWavesPriceAsset = !isDefined(o.assetPair.priceAsset)\n        let rightPair = (o.assetPair.amountAsset == amountAsset) && isWavesPriceAsset\n        sigVerify(o.bodyBytes, o.proofs[0], traderPublicKey)\n        && rightPair\n        && o.expiration - o.timestamp < 120*1000\n        && o.matcherPublicKey == matcherPublicKey\n    case t:SetScriptTransaction | TransferTransaction =>\n        sigVerify(t.bodyBytes, t.proofs[0], ownerPublicKey)\n    case _ =>\n        false\n }","type":"ride","id":"smart-accounts/AuthorizedTrader.ride","sha":"93e87d51d97be39f6eb56d0173d8c8ad1610e854","readonly":true},{"name":"Multisig.ride","content":"{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n#define public keys\nlet alicePubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'\nlet bobPubKey    = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'\nlet cooperPubKey = base58'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD'\n\n#check whoever provided the valid proof\nlet aliceSigned  = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey  )) then 1 else 0\nlet bobSigned    = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey    )) then 1 else 0\nlet cooperSigned = if(sigVerify(tx.bodyBytes, tx.proofs[2], cooperPubKey )) then 1 else 0\n\n#sum up every valid proof to get at least 2\naliceSigned + bobSigned + cooperSigned >= 2\n","type":"ride","id":"smart-accounts/Multisig.ride","sha":"33df8c96eececaf24bb55a33bd6a6ab66fa3acb1","readonly":true},{"name":"XmasTree.ride","content":"# Contract example from tradisys.com team\n\n### Prerequisites ###\n# - balance = playersPrize + dataTransactionFee * 3 + transferTransactionFee\n# - no data required\n#####################\n\n### Player's precautions ###\n# - Smart account balance is >= playersPrize + dataTransactionFee * 2 + transferTransactionFee\n# - Data on account: playersPublicKey matches player's public key, lockedAt is approximately equal to current block height.\n############################\n\n### Normal flow ###\n# 1) Data transaction from server, data = [lockedAt, playersPublicKey]. lockedAt = height or height - 1. Transition: InitialState -> LockedState\n# 2) Data transaction from player, data = [playersChoice]. Transition: LockedState -> PlayerRevealedHisChoiceState\n# 3) Transfer transaction  from player, amount = donation\n# 4) Data transaction from server, data = [serversChoice, serversSalt]. Transition: PlayerRevealedHisChoiceState -> WinnerIsDeterminedState\n# 5) Transfer transaction, recipients = winner (playersPrize + donation). Transition: PlayerDecidedNotToSendDonationState -> <InvalidState>\n###################\n\n### Emergency flow ###\n# 1) Normal flow #1 is completed, but user hasn't done any actions in timeoutInBlocks blocks - we allow server to override\n#    playersPublicKey and lockedAt data. Transition: UserDecidedNotToPlayState -> LockedState\n# 2) Normal flow #2 is completed, but server hasn't done any actions in timeoutInBlocks * 2 blocks from lockedAt - we allow player\n#    to widthdraw all the money. Transition: ServerDecidedNotToPlayState -> <InvalidState>\n# 3) Players sent his choice (Normal Flow #2), but not his money (Normal flow #3) - we allow server to withdraw all the money.\n#    Transition: PlayerDecidedNotToSendDonationState -> <InvalidState>\n######################\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n### Injected values ###\nlet serversPublicKey = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'\nlet enctyptedServersChoice = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM' # keccak256(serversChoice + serversSalt)\nlet donation = 100_000_000 # waves * 100_000_000, eq. 300000000 (= 3 waves)\nlet playersPrize = 100_000_000 # waves * 100_000_000, eq. 400000000 (= 2 waves)\nlet boxesCount = 5\n#######################\n\n### Values from data ###\nlet maybeDataPlayersPublicKey = getString(tx.sender, \"playersPublicKey\")\nlet dataPlayersPublicKey = fromBase58String(extract(maybeDataPlayersPublicKey))\nlet dataLockedAt = extract(getInteger(tx.sender, \"lockedAt\"))\nlet maybeDataPlayersChoice = getInteger(tx.sender, \"playersChoice\")\nlet dataPlayersChoice = extract(maybeDataPlayersChoice)\nlet maybeDataServersChoice = getInteger(tx.sender, \"serversChoice\")\nlet dataServersChoice = extract(maybeDataServersChoice)\n########################\n\nlet timeoutInBlocks = 120\nlet dataTransactionFee = 500000 # 0.001 + 0.004 (smart account fee)\nlet transferTransactionFee = 500000 # 0.001 + 0.004 (smart account fee)\nlet serversAddress = addressFromPublicKey(serversPublicKey)\nlet playersAddress = addressFromPublicKey(dataPlayersPublicKey)\nlet accountBalance = wavesBalance(tx.sender)\n\nlet senderIsServer = sigVerify(tx.bodyBytes, tx.proofs[0], serversPublicKey)\nlet senderIsPlayer = sigVerify(tx.bodyBytes, tx.proofs[0], dataPlayersPublicKey)\n\n### States ###\n# InitialState @ no data is deployed to account\n# Balance: playersPrize + dataTransactionFee * 3 + transferTransactionFee\nlet isInitialState = !isDefined(maybeDataPlayersPublicKey) && accountBalance >= playersPrize + dataTransactionFee * 3 + transferTransactionFee\n\n# LockedState @ account is locked for a specific player by server\n# State: playersPublicKey and lockedAt in data; height <= lockedAt + timeoutInBlocks\n# Balance: donation + dataTransactionFee * 2 + massTransferTransactionFee\nlet dataIsValidForLockedState = isDefined(maybeDataPlayersPublicKey) && !isDefined(maybeDataPlayersChoice)\nlet lockedStateTimeout = height > dataLockedAt + timeoutInBlocks\nlet isLockedState = dataIsValidForLockedState && !lockedStateTimeout\n\n# UserDecidedNotToPlayState @ user didn't send a data transaction in timeoutInBlocks blocks\nlet isUserDecidedNotToPlayState = dataIsValidForLockedState && lockedStateTimeout\n\n# PlayerRevealedHisChoiceState @ player sent a data transaction with his choice (and donationted simultaneously)\n# State: playersPublicKey, lockedAt, playersChoice in data; height <= lockedAt + timeoutInBlocks * 2\n# Balance: playersPrize (playersPrize + donation is fine too) + dataTransactionFee + transferTransactionFee\nlet dataIsValidForPlayerRevealedState = isDefined(maybeDataPlayersChoice) && !isDefined(maybeDataServersChoice)\nlet playerRevealedStateTimeout = (height > dataLockedAt + timeoutInBlocks * 2) && (accountBalance >= playersPrize + donation + dataTransactionFee + transferTransactionFee)\nlet isPlayerRevealedHisChoiceState = dataIsValidForPlayerRevealedState && !playerRevealedStateTimeout\n\n# ServerDecidedNotToPlayState @ the same as PlayerRevealedHisChoiceState, but after timeoutInBlocks * from lockedAt\n# Balance: strictly >= playersPrize + donation + dataTransactionFee + transferTransactionFee, otherwise player will be able to publish data transaction w/o transfer\nlet isServerDecidedNotToPlayState = dataIsValidForPlayerRevealedState && playerRevealedStateTimeout\n\n# WinnerIsDeterminedState @ we are ready to send money to winner\n# Balance: strictly >= playersPrize + donation + transferTransactionFee\nlet isDataValidForWinnerIsDeterminedState = isDefined(maybeDataServersChoice)\nlet isBalanceValidForWinnerIsDeterminedState = accountBalance >= playersPrize + donation + transferTransactionFee\nlet isWinnerIsDeterminedState = isDataValidForWinnerIsDeterminedState && isBalanceValidForWinnerIsDeterminedState\n\n# PlayerDecidedNotToSendDonationState @ player sent data transaction with his choice, but not a transfer transaction with donation\nlet isPlayerDecidedNotToSendDonationState = isDataValidForWinnerIsDeterminedState && !isBalanceValidForWinnerIsDeterminedState\n##############\n\nmatch (tx) {\n  case dtx:DataTransaction => (\n    let payloadSize = size(dtx.data)\n    let firstPayloadName = dtx.data[0].key\n    let secondPayloadName = dtx.data[1].key\n    let firstPayloadAsInteger = extract(getInteger(dtx.data, firstPayloadName))\n    let secondPayloadAsString = extract(getString(dtx.data, secondPayloadName))\n    let dataFeeIsOk = dtx.fee == dataTransactionFee\n\n    if (isInitialState || isUserDecidedNotToPlayState) then ( # Normal flow #1, Emergency flow #1\n        let validLockedAtIsProvided = firstPayloadName == \"lockedAt\" && (firstPayloadAsInteger <= height && height - firstPayloadAsInteger <= 5)\n        let playersPublicKeyIsProvided = secondPayloadName == \"playersPublicKey\"\n        senderIsServer && dataFeeIsOk && validLockedAtIsProvided && playersPublicKeyIsProvided && payloadSize == 2\n    ) else if (isLockedState) then ( # Normal flow #2\n        let validPlayersChoiceIsProvided = firstPayloadName == \"playersChoice\" && (firstPayloadAsInteger >= 0 && firstPayloadAsInteger < boxesCount)\n        senderIsPlayer && dataFeeIsOk && validPlayersChoiceIsProvided && payloadSize == 1\n    ) else if (isPlayerRevealedHisChoiceState) then ( # Normal flow #4\n        let validServerChoiceWasProvided = firstPayloadName == \"serversChoice\" && (firstPayloadAsInteger >= 0 && firstPayloadAsInteger < boxesCount)\n        let serversSaltWasProvided = secondPayloadName == \"serversSalt\"\n        let choiceAndSaltMatchesHardcodedValue = keccak256(toBytes(toString(firstPayloadAsInteger) + secondPayloadAsString)) == enctyptedServersChoice\n\n        senderIsServer && dataFeeIsOk && validServerChoiceWasProvided && serversSaltWasProvided && choiceAndSaltMatchesHardcodedValue && payloadSize == 2\n    ) else (\n        false \n    )\n  )\n  case ttx:TransferTransaction => (\n      let transferFeeIsOk = ttx.fee == transferTransactionFee\n\n      if (isWinnerIsDeterminedState) then ( # Normal flow #5\n        let winnerAddress = if (dataServersChoice == dataPlayersChoice) then playersAddress else serversAddress\n          let prizeGoesToWinner = ttx.recipient == winnerAddress\n\n        transferFeeIsOk && prizeGoesToWinner && ttx.amount == playersPrize + donation\n      ) else if (isServerDecidedNotToPlayState) then ( # Emergency flow #2\n        let recipientIsPlayer = ttx.recipient == playersAddress\n\n        transferFeeIsOk && recipientIsPlayer && ttx.amount == playersPrize + donation\n      ) else if (isPlayerDecidedNotToSendDonationState) then ( # Emergency flow #3\n        let recipientIsServer = ttx.recipient == serversAddress\n        transferFeeIsOk && recipientIsServer && ttx.amount == playersPrize\n      ) else (\n        false\n      )\n  )\n  case _ => false\n}\n","type":"ride","id":"smart-accounts/XmasTree.ride","sha":"b2e314c0b29503473d033ee30fe7e855c2f12ce0","readonly":true},{"name":"casino.ride","content":"# If you want to test it on TestNet\n# You will need Keeper (Don't forget TO SWITCH IT TO TESTNET MODE!)\n# go http://185.43.6.227:8000\n# and Play\n#\n#\n# This is an account script of a roulette in a casino\n# Results of games are put into the blockchain by the Oracle periodically (every 5 minutes).\n# Oracle posts its messages to separate account \n#\n# How to make bet\n# \n# To participate you need to Transfer Waves to this account - make Payment and register the bet \n#\n# 1. Payment\n#    Just send money to the casino's account\n#\t One payment - one bet. Minimal bet amount = 0.5.\n#    Bet registration fee (see next paragraph) is substracted from your payment.\n# 2. Register payment as the bet\n#    You need to register the bet for the game round. Choose round by it's timestamp (happens every 5 minutes). \n#    To register you need send DataTransaction from the script account signed by Payment sender and containing the following data:\n#    (<payment_id>, guess), (<payment_id>_round, timestamp_of_the_round)\n# \t timestamp_of_the_round - in UTF8 encoding in bytes(13 bytes)\n#    Guess is a ByteArray in the following format:\n#     type of bet (1 byte), guess (1 byte)\n#     Bet type could be one of the following (in braces possible 'guess' values are defined):\n#     0 - number (number)\n#     1 - red (0) or black (1)\n#     2 - even (0) or odd (1)\n#     3 - 1st half of the desk (0) and 2nd half (1)\n#     4 - 1st third of the desk (0), 2nd third (1), 3rd third (2)\n#     5 - 1st row of the desk (0), 2nd row (1), 3rd row (2)\n#\n# How to get your prise in case you win \n#\n# In case you guess right you can get more money then your bet (see koeff variable in the code).\n# Formula is: (paymentTx.amount - registerBetTxFee) * koeff - dataTxsFees - withdrawTx.fee\n#\n# You win the round defined by your Bet Registration in case the Oracle\n# put equal value to the round's data. Oracle puts DataTransaction where\n#  - the key is the timestamp of the round in UTF8 format converted to ByteArray\n#  - value is ByteArray containing\n#    1) version (1 byte)\n#\t 2) wining value for bet of type0 - number (1 byte)\n#\t 3) wining value for bet of type1 - red/black (1 byte)\n#\t 4) wining value for bet of type2 - even/odd (1 byte)\n#\t 5) wining value for bet of type3 - halfs of the desk (1 byte)\n#\t 6) wining value for bet of type4 - thirds of the desk (1 byte)\n#\t 7) wining value for bet of type5 - rows of the desk (1 byte)\n#\n# You can also get your money back if you just sent Payment, but didn't register it as a bet.\n# In this case you need to do the same as described below, but amount would be the following:\n# paymentTx.amount - dataTxsFees - withdrawTx.fee \n#\n# To get money you need to do the following:\n# 1. Create withdraw - Transfer transaction. Amount of money must be calculated according to type of your bet\n#    and concider fees - fee of withdraw transaction and fees of data transactions (see 2.)\n#    Withdraw transaction must:\n#\t 1) be originated from the Casino account (sender - is the Casino account public key)\n#    2) be signed by Payment sender\n#\t 3) contain Payment transaction id in the second proof.\n#    Don't send withdraw yet, just remember it's id (<withdraw_id>). \n#\t You will send it on step 3, after the DataTransaction. \n# 2. Create and send DataTransaction. This DataTransaction links your Payment to the Withdraw.\n#    Because of this DataTransaction you only able to get money once per payment which won. \n#\t In case you sent DataTransaction but lost your Withdraw transaction (e.g. it is expired),\n#    you can provide another DataTransaction with new link of Payment to Withdraw.\n#    Since DataTransactions are made from the name of the Casino account fees \n#\t will be substracted from your prise.\n#\t DataTransaction must: \n#    1) be originated from the Casino account (sender - is the Casino account public key)\n#    2) be signed by Payment sender\n#    3) contain the following (key, value) pairs:\n#    (<payment_id>_withdraw, <withdraw_id>), (<payment_id>_withdraw_fees, sum_ammount_of_data_txs_fees)\n#\t sum_ammount_of_data_txs_fees - is sum of fees of all DataTransactions for this payment.\n# 3. When DataTransaction is in the blockchain send Withdraw created on step 1.\n#\n# Donation \n# if you find this script useful, you can donate\n# Waves address: 3P5VCmMc7fqqJijHaS3yB8jCwq7rgmLpszx\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet me = tx.sender\nlet oracle = extract(addressFromString(\"3NCzaYTNDGtR8zf9yfcqePFjCqFx9S5zhs4\"))\nlet minWithdrawFee = 500000\nlet registerBetTxFee = 500000\n\nmatch(tx) {\n\tcase withdrawTx: TransferTransaction =>\n\t\t# proofs[0] contains signiture by payment sender\n\t\t# proofs[1] contains payment Tx id\n\t\tlet txId = extract(getString(me, toBase58String(tx.proofs[1]) + \"_withdraw\"))\n\t\tmatch(transactionById(tx.proofs[1])) {\n\t\t\tcase paymentTx: TransferTransaction =>\n\t\t\t   let isPaymentTookPlace = txId == toBase58String(tx.id) && sigVerify(tx.bodyBytes, tx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\tlet feesKey = toBase58String(tx.proofs[1]) + \"_withdraw_fees\"\n\t\t\t\tlet dataTxsFees = extract(getInteger(me, feesKey))\n\n\t\t\t\tlet guessUnit = getBinary(me, toBase58String(tx.proofs[1]))\n\t\t\t\t\n\t\t\t\tlet correctAmount = if (!isDefined(guessUnit)) then\n\t\t\t\t{\n\t\t\t\t\t# return back payment\n\t\t\t\t\tpaymentTx.amount - dataTxsFees - withdrawTx.fee\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t# get win prise\n\t\t\t\t\tlet guess = extract(guessUnit)\n\n\t\t\t\t\tlet type = take(guess, 1)\n\t\t\t\t\tlet val = drop(guess, 1)\n\t\t\t\t\tlet key = extract(getString(me, toBase58String(tx.proofs[1]) + \"_round\"))\n\n\t\t\t\t\tlet valComplex = extract(getBinary(oracle, key))\n\n\t\t\t\t\tlet koeff =\n\t\t\t\t\t\tif (type == drop(toBytes(0), 7)) then 36\n\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then 3\n\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then 3\n\t\t\t\t\t\telse 0\n\n\t\t\t\t\t(paymentTx.amount - registerBetTxFee) * koeff - dataTxsFees - withdrawTx.fee\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t(isPaymentTookPlace || throw(\"There was no bet\")) \n\t\t\t\t&& \n\t\t\t\t((withdrawTx.amount == correctAmount) || throw(\"Amount is incorrect. Correct amount is \" + toString(correctAmount))) \n\t\t\t\t&& \n\t\t\t\t((!isDefined(withdrawTx.feeAssetId) && !isDefined(withdrawTx.assetId)) \n\t\t\t\t|| throw(\"Withdraw and fee must be in WAVES\"))\n\n\t\t\tcase _ => false\n\t\t}\n\n\tcase dtx: DataTransaction =>\n\n\t\tif (size(dtx.data) == 3) then\n\t\t{\n\t\t\t# Data Tx for BET REGISTRATION\n\t\t\t\t\t\t\n\t\t\tlet minBet = \t  50000000\n\t\t\tlet maxSumBet = 1000000000 # max sum bet for round\n\t\t\t\n\t\t\tlet paymentTxIdStr = extract(dtx.data[0].key)\n\t\t\t\n\t\t\tlet guessStr = extract(getString(dtx.data, paymentTxIdStr))\n\t\t\tlet paymentRoundKey = paymentTxIdStr + \"_round\"\n\t\t\tlet paymentRound = extract(getString(dtx.data, paymentRoundKey))\n\t\t\t\n\t\t\tlet sumBetsOld = if isDefined(getInteger(me, paymentRound + \"_betsSum\")) \n\t\t\t\t\t\t\t\tthen extract(getInteger(me, paymentRound + \"_betsSum\")) \n\t\t\t\t\t\t\t\telse 0\n\t\t\tlet sumBetsNew = extract(getInteger(dtx.data, paymentRound + \"_betsSum\"))\n\n\t\t\tlet itsTooLate = isDefined(getString(me, paymentRound + \"_stop\"))\n\t\t\t\n\t\t\tlet isPaymentAlreadyMentioned = isDefined(getString(me, paymentTxIdStr))\n\n\t\t\tlet paymentTx = transactionById(fromBase58String(paymentTxIdStr))\n\t\t\tmatch (paymentTx) {\n\t\t\t\tcase paymentTx : TransferTransaction =>\n\t\t\t\t\t# data-transaction must be signed by payment sender\n\t\t\t\t\tlet isDtxSignedByPayer = sigVerify(dtx.bodyBytes, dtx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\t\tlet correctSumBets = sumBetsOld + paymentTx.amount - dtx.fee # data tx fee is payed by Payment sender from its bet\n\n\t\t\t\t\t(addressFromRecipient(paymentTx.recipient) == me || throw(\"Incorrect recipient of the payment\"))\n\t\t\t\t\t&&\n\t\t\t\t\t(!isPaymentAlreadyMentioned || throw(\"This transfer is already used as a bet\")) \n\t\t\t\t\t&& \n\t\t\t\t\t((sumBetsNew == correctSumBets)\n\t\t\t\t\t|| throw(\"Wrong value for Sum of Bets. Must be \" + toString(correctSumBets)))\n\t\t\t\t\t&&\n\t\t\t\t\t((sumBetsNew < maxSumBet) \n\t\t\t\t\t|| throw(\"Maximum amount of bets for round \" + toString(maxSumBet) + \". With your bet it's \" + toString(sumBetsNew)))\n\t\t\t\t\t&&\n\t\t\t\t\t((dtx.fee == registerBetTxFee) \n\t\t\t\t\t|| throw(\"Fee of bet registration data transaction must be \" + toString(registerBetTxFee)))\n\t\t\t\t\t&&\n\t\t\t\t\t((paymentTx.amount - registerBetTxFee >= minBet) || throw(\"Your Bet amount is less then minimal bet \" + toString(minBet) + \". Payment amount for such bet must be \" + toString(minBet+registerBetTxFee)))\n\t\t\t\t\t&& \n\t\t\t\t\t((!isDefined(paymentTx.feeAssetId) || throw(\"Paymnet must be in WAVES\")))\n\t\t\t\t\t&& \n\t\t\t\t\t(!itsTooLate || throw(\"It's too late to play this round. Try next one\"))\n\n\t\t\t\t\t \n\n\t\t\t\tcase _ => false\n\t\t\t}\t\t\n\t\t}\n\t\telse if (size(dtx.data) == 2) then\n\t\t{\n\t\t\t# Data Tx for WITHDRAW registration\n\n\t\t\t# payment transaction in the first key-value.\n\t\t\t# Data tx must be signed by payment sender\n\n\t\t\tlet isDataCountOk = size(dtx.data) == 2\n\n\t\t\tlet paymentTxIdStr = dropRight(extract(dtx.data[0].key), 9) # drop \"_withdraw\"\n\t\t\tlet feesKey = paymentTxIdStr + \"_withdraw_fees\"\n\t\t\tlet paymentTx = transactionById(fromBase58String(paymentTxIdStr))\n\t\t\tlet newFees = extract(getInteger(dtx.data, feesKey))\n\t\t\tlet oldFeesUnit = getInteger(me, feesKey)\n\t\t\tlet oldFees = if isDefined(oldFeesUnit)\n\t\t\t\t\t\t\tthen extract(oldFeesUnit)\n\t\t\t\t\t\t\telse 0\n\n\t\t\tlet isFeeCorrect = newFees == oldFees + dtx.fee\n\n\t\t\t#if payment already mentioned in the State, the corresponding withdraw tx must not exist\n\t\t\t\n\t\t\tlet withdrawTxIdUnit = getString(me, paymentTxIdStr)\n\t\t\tlet isPaymentAlreadyMentioned = isDefined(withdrawTxIdUnit)\n\n\t\t\tlet withdrawTransactionId = fromBase58String(extract(withdrawTxIdUnit))\n\n\t\t\tmatch (paymentTx) {\n\t\t\t\tcase paymentTx : TransferTransaction =>\n\t\t\t\t\t# data-transaction must be signed by payment sender\n\t\t\t\t\tlet isDtxSignedByPayer = sigVerify(dtx.bodyBytes, dtx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\t\t#if payment correct\n\t\t\t\t\tif (addressFromRecipient(paymentTx.recipient) == me\n\t\t\t\t\t\t&&\n\t\t\t\t\t\t(!isPaymentAlreadyMentioned || !isDefined(transactionById(withdrawTransactionId)) ) \n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisDtxSignedByPayer\n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisFeeCorrect\n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisDataCountOk) \n\t\t\t\t\tthen\n\t\t\t\t\t\tlet guess = extract(getBinary(me, paymentTxIdStr))\n\n\t\t\t\t\t\tlet type = take(guess, 1)\n\t\t\t\t\t\tlet key = extract(getString(me, paymentTxIdStr + \"_round\"))\n\n\t\t\t\t\t\tlet valComplex = extract(getBinary(oracle, key))\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet koeff = \n\t\t\t\t\t\t\tif  \t(type == drop(toBytes(0), 7)) then 36\n\t\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then 3\n\t\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then 3\n\t\t\t\t\t\t\telse 0\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet valReal = \n\t\t\t\t\t\t\tif  \t(type == drop(toBytes(0), 7)) then drop(take(valComplex, 2), 1)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then drop(take(valComplex, 3), 2)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then drop(take(valComplex, 4), 3)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then drop(take(valComplex, 5), 4)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then drop(take(valComplex, 6), 5)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then drop(take(valComplex, 7), 6)\n\t\t\t\t\t\t\telse throw(\"Incorrect type of guess provided\")\n\n\t\t\t\t\t\tlet isWin = drop(guess, 1) == valReal\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet isMoneyStillEnough = newFees < (paymentTx.amount - registerBetTxFee) * koeff + minWithdrawFee\n\n\t\t\t\t\t\t(isWin || throw(\"You didn't guess\")) \n\t\t\t\t\t\t&& \n\t\t\t\t\t\t(isMoneyStillEnough || throw(\"Not enough money for withdraw\")) \n\n\t\t\t\t\telse false\n\t\t\t\t\t\n\t\t\t\tcase _ => false\n\t\t\t}\n\t\t}\n\t\telse \n\t\t\tfalse\n\t\t\n\tcase _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)\n\n}\n","type":"ride","id":"smart-accounts/casino.ride","sha":"6fa6df04bc48291e4ae663109411611ba29df470","readonly":true},{"name":"guess.ride","content":"# in the state of this account, there are two fields  \n# \"question\" - with some question and \n# \"hashed answer\" - with an answer to this question \n# which is hashed by keccak256 algorithm user can send \n# any number of WAVES from this account if he/she has \n# a correct answer in an attachment of TransferTransaction  \n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet this=extract(tx.sender)\n\nmatch(tx)\n{\n    case t : TransferTransaction =>\n        let correctAnswer = extract(getBinary(this, \"hashed answer\"))\n        let answer = keccak256(t.attachment)\n\n        correctAnswer == answer \n        && !isDefined(t.assetId)\n    case s: SetScriptTransaction | DataTransaction =>\n        sigVerify(s.bodyBytes, s.proofs[0], s.senderPublicKey)\n    case _ => false\n}\n","type":"ride","id":"smart-accounts/guess.ride","sha":"b0afaed1c55813b0dccc0994cb4972364b783702","readonly":true}]},{"name":"smart-assets","sha":"fe04f0c4f57c1f0649d6b88e9b3d4747a94feae8","content":[{"name":"FixedPriceTicket.ride","content":"# This token represents a ticket that can be traded at face value only.\n#\n# Token price is hard coded into the script, and exchange is allowed\n# only at that price. Such a token can be useful for show or sport\n# tickets to help combat ticketing fraud.\n#\n# Additional restriction: a ticket can be burnt only after the show is over.\n#\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet expiration = 1552064400000  # March 8 2019, 8pm Moscow time\nlet price = 1000000000          # 10 WAVES\nmatch tx {\n    case e: ExchangeTransaction =>\n        let pair = e.buyOrder.assetPair\n        let tradedForWaves = ! isDefined(pair.amountAsset) ||\n                             ! isDefined(pair.priceAsset)\n        tradedForWaves && e.price == price\n    case b: BurnTransaction =>\n        b.timestamp > expiration\n    case _: TransferTransaction | MassTransferTransaction => true\n    case _  => false\n}\n","type":"ride","id":"smart-assets/FixedPriceTicket.ride","sha":"497f04af0aad5352152cfcf715b1f5aeb89c2f7e","readonly":true},{"name":"FixedRateExchange.ride","content":"# This token can be bought/sold for WAVES only at a rate published by\n# asset issuer.\n#\n# The issuer publishes the exchange rate with a data transaction on his\n# account. The actual exchange rate must match the published rate up to\n# 7th significant digit.\n#\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet issuer = Address(base58'3issuerAddress')\nlet assetId = base58'ThisAsset1d'\nmatch tx {\n    case ex: ExchangeTransaction =>\n        let pair = AssetPair(assetId, unit)\n        let rate = extract(getInteger(issuer, \"exchangeRate\"))\n        let rateDiff = rate - fraction(100000000, ex.price, ex.amount)\n        ex.buyOrder.assetPair == pair && rateDiff > -100 && rateDiff < 100\n    case _ => true\n}\n","type":"ride","id":"smart-assets/FixedRateExchange.ride","sha":"13cafa315a9f0bf191803961542f3675e950cd1d","readonly":true},{"name":"HotPotatoToken.ride","content":"# This is a token-game\n# When you receive this token, you have 5000 blocks to transfer it to somebody else,\n# after that 5000 blocks you will have to pay the fee more than 1 Waves to transfer it.\n# you have to pay 10 Waves as fee to burn it, you can transfer it only to an account with >10 Waves\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet minimumWavesBalance = 10_00_000_000\nlet moveTimeInBlocks = 5000\nlet minimalFeeToMove = 1_0_000_000\nlet minimalFeeToBurn = 5_0_000_000\n\nmatch (tx) {\n    case t:TransferTransaction => {\n\n        # to get a height of blockchain when HotPotato was received we expect transaction id\n        # of incoming transfer transaction in the attachment\n        let txId = t.attachment\n\n        # script can check that current recipient doesnt hold HotPotato\n        # but not now :)\n\n        # let currentRecipientBalance = assetBalance(t.recipient, t.assetId)\n        let currentRecipientWavesBalance = wavesBalance(t.recipient)\n\n        # assetId equals to issue transaction id, so we can get issuer public key (and address) from the issue transaction\n        let transaction = transactionById(extract(t.assetId))\n\n        match (transaction) {\n            case issueTx:IssueTransaction => {\n                # issuer is allowed to send tokens without any additional requirements except signature and recipient Waves balance (should be >= 10)\n                let transactionByIssuer = t.senderPublicKey == issueTx.senderPublicKey\n                if (transactionByIssuer) then {\n                    if (currentRecipientWavesBalance < minimumWavesBalance) then {\n                        throw(\"Current balance is less than minimalWavesBalance\")\n                    }else {\n                        true\n                    }\n                }else if (size(t.attachment) < 32) then {\n                    throw(\"Attachment should contain transaction id \")\n                }else{\n                    # getting incoming transaction by id (from the attachment)\n                    let receiveTx = transactionById(txId)\n                    match (receiveTx) {\n                        case recTx:TransferTransaction | MassTransferTransaction => {\n                            # get the number of block when address get a potato\n                            let receivedBlockNumber = extract(transactionHeightById(recTx.id))\n                            # check that we received assets in allowed span\n                            let receivedAssetInLastNBlocks = (height - receivedBlockNumber) <= moveTimeInBlocks && t.assetId == recTx.assetId\n                            let feeMore1Waves = t.fee >= minimalFeeToMove\n                            if (!receivedAssetInLastNBlocks && !feeMore1Waves) then {\n                                throw(\"You got potato long time ago, now you have to pay 1 WAVES fee\")\n                            }else {\n                                receivedAssetInLastNBlocks || feeMore1Waves\n                            }\n                        }\n                        case _ => throw(\"Receive tx should be a transfer\")\n                    }\n                }\n            }\n            case _ => throw(\"Not issue tx\")\n        }\n    }\n    # we allow to burn a token only if fee > 5 waves\n    case burn: BurnTransaction => {\n        if (burn.fee < minimalFeeToBurn) then {\n            throw(\"You have to pay 5 WAVES to burn this token\")\n        }else{\n            true\n        }\n    }\n    # MassTransfer and SetAssetScript transactions are allowed only for issuer\n    case mass: MassTransferTransaction | SetAssetScriptTransaction => {\n        let transaction = transactionById(extract(mass.assetId))\n\n        match (transaction) {\n            case issueTx:IssueTransaction => {\n                mass.senderPublicKey == issueTx.senderPublicKey\n            }\n            case _ => throw(\"Bad issue tx type\")\n        }\n    }\n    case _ => throw(\"You only can transfer this token\")\n  }","type":"ride","id":"smart-assets/HotPotatoToken.ride","sha":"036b7bbf4bbf366d759b15fb008075fe179484bf","readonly":true},{"name":"LicenseToTrade.ride","content":"# For example you want to create an asset that can be traded only by those clients who have some special asset as a license\n# So you can regulate who is able to trade your token or it may be usefull in games,\n# sending this token can give the character an ability to trade or perform other skills\n# or amount of this token can imitate the health points of the players, so you can \"trade\" only if you are alive:)\n#\n# In this script case you can buy or sell SmartAsset only if your WavesCommunity token balance is greater then 10\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet WCTlicenseToTradeAsset = base58'2CjLFYkp4W4sEAxCjFG9oD3smfhvV6yQnNmiJyexbLdu'\nmatch (tx) {\n    case tx:ExchangeTransaction =>\n        assetBalance(tx.sellOrder.sender, WCTlicenseToTradeAsset) > 10_00 && assetBalance(tx.buyOrder.sender, WCTlicenseToTradeAsset) > 10_00\n    case _ => true\n}","type":"ride","id":"smart-assets/LicenseToTrade.ride","sha":"eafef93751f32c8eea779a7e5c90f181cf46c924","readonly":true},{"name":"MainCoinsTrade.ride","content":"\n# You can disable transfer, masstransfer and burn of the token,\n# Also you can define in what pairs your token can be traded.\n# This token can be traded only with BTC/ETH/LTC/ZEC/DASH/XMR/USD/EUR price assets\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet BTCId = base58'8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS'\nlet ETHId = base58'474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu'\nlet LTCId = base58'HZk1mbfuJpmxU1Fs4AX5MWLVYtctsNcg6e2C6VKqK8zk'\nlet ZECId = base58'BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa'\nlet DASHId = base58'B3uGHFRpSUuGEDWjqB9LWWxafQj8VTvpMucEyoxzws5H'\nlet XMRId = base58'5WvPKSJXzVE2orvbkJ8wsQmmQKqTv9sGBPksV4adViw3'\nlet USDId = base58'Ft8X1v1LTa1ABafufpaCWyVj8KkaxUWE6xBhW6sNFJck'\nlet EURId = base58'Gtb1WRznfchDnTh37ezoDTJ4wcoKaRsKqKjJjy7nm2zU'\n\nmatch tx {\n  case e : ExchangeTransaction =>\n    e.sellOrder.assetPair.priceAsset == BTCId || e.sellOrder.assetPair.priceAsset == ETHId || e.sellOrder.assetPair.priceAsset == LTCId || e.sellOrder.assetPair.priceAsset == ZECId || e.sellOrder.assetPair.priceAsset == DASHId || e.sellOrder.assetPair.priceAsset == XMRId || e.sellOrder.assetPair.priceAsset == USDId || e.sellOrder.assetPair.priceAsset == EURId\n  case _:TransferTransaction | MassTransferTransaction | BurnTransaction => false\n  case _ => true\n}\n","type":"ride","id":"smart-assets/MainCoinsTrade.ride","sha":"8b08f60327b96779eec6249a2236bff9021de686","readonly":true},{"name":"Medal.ride","content":"# This is a medal token.\n#\n# Medals are awarded to people using Transfer or MassTransfer. The issuer\n# can mint new medals or burn unused ones. The medal asset should have\n# zero decimals.\n#\n# A person who's awarded a medal can not transfer nor sell it,\n# but can give it back to the issuer.\n#\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet master = addressFromString(\"3masterAddress\")\nmatch tx {\n    case t: TransferTransaction =>\n        t.sender == master || t.recipient == master\n    case mt: MassTransferTransaction =>\n        mt.sender == master\n    case _: ExchangeTransaction => false\n    case _ => true\n}\n","type":"ride","id":"smart-assets/Medal.ride","sha":"9ddf92907b91c8dd697ec3d6ab225f3d97824f96","readonly":true},{"name":"RecipientSignature.ride","content":"\n# General idea of this token is to allow transfer only with recipient's permisson. \n# Token ownership can be used as a proof of physycal object ownership and token transfer as a proof of 'real world' object transfer.\n\n# To use this token:\n# 1. Sender creates tx without proof and sends it to recipient\n# 2. Recipient calculates signature, adds his public key and signature to attachment field. Sends tx back to sender.\n# 3. Sender signs tx with attachment. Tx can now be sent to blockchain\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\n# Set network byte. 87 for mainnet\nlet NETWORKBYTE = takeRight(toBytes(87), 1)\n\nmatch (tx) {\n    # Only allow transfer transactions\n    case t:TransferTransaction => {\n        # Since smart assets don't have access to proofs, attachment is used, but attachment is also signed.\n        # For that reason we will verify signature against tx without attachment\n        let txWithoutAttachment = dropRight(t.bodyBytes, 97) + takeRight(toBytes(0), 1)\n\n        # Attachment contains recipient public key and signature\n        let recipientPublicKeyAndSignature = t.attachment\n        let recipientPublicKey = take(recipientPublicKeyAndSignature, 32)\n        let recipientSignature = takeRight(recipientPublicKeyAndSignature, 64)\n\n        # Get recipient address from public key in attachment\n        let recipientPublicKeyHash = take(keccak256(blake2b256(recipientPublicKey)), 20)\n        let rpkWithVersionAndByte = takeRight(toBytes(1), 1) + NETWORKBYTE + recipientPublicKeyHash\n        let checksum = take(keccak256(blake2b256(rpkWithVersionAndByte)), 4)\n        let recipientAddressFromPublicKey = rpkWithVersionAndByte + checksum\n        let recipientAddressFromTx = addressFromRecipient(t.recipient).bytes\n        \n        # Verify that tx.recipient equals recipient from attsachment\n        if (recipientAddressFromPublicKey != recipientAddressFromTx) then throw(\n            \"Recipient address error:\" + toBase58String(recipientAddressFromPublicKey)\n            ) else {\n        # Verify recipient signature\n        if (!sigVerify(txWithoutAttachment, recipientSignature, recipientPublicKey))  then  throw(\n            \"Invaid recipient signature:\" + toBase58String(recipientSignature) + \"\\n BodyBytes:\" + toBase64String(txWithoutAttachment)\n            ) else {\n            true\n        }}\n    }\n    # No exchange or masstransfer\n    case _ => false\n  }\n","type":"ride","id":"smart-assets/RecipientSignature.ride","sha":"82d6a2b8399054c305694a074ab193bcaa2acc5e","readonly":true},{"name":"ScheduleTrade.ride","content":"\n# Also you can issue an asset that can be traded on DEX only according with some schedule.\n# For example every day from 10 to 19 o’clock, from monday to friday, like on real exchanges.\n\n# First of all you have to publish a data transaction with a schedule for the next week timestamps,\n# and renew it every week (it is possible to automate this task with a cron script)\n\n# This is the example of data transactions with a an approximate height from 10 to 19 o'clock from 25 February to the 1st of March:\n# You can issue an asset that will verify that current blockchain height is between tradeStart and tradeEnd\n# Example or data TX:\n\n# {\n#   \"type\": 12,\n#   \"data\": {\n#     \"fee\": {\n#       \"assetId\": \"WAVES\",\n#       \"tokens\": \"0.005\"\n#     },\n#     \"data\": [\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"mondayTradeStart\",\n#         \"value\": 1411748\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"mondayTradeEnd\",\n#         \"value\": 1412288\n#       },\n#         {\n#         \"type\": \"integer\",\n#         \"key\": \"tuesdayTradeStart\",\n#         \"value\": 1413188\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"tuesdayTradeEnd\",\n#         \"value\": 1413728\n#       },\n#\n#         {\n#         \"type\": \"integer\",\n#         \"key\": \"wednesdayTradeStart\",\n#         \"value\": 1414628\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"wednesdayTradeEnd\",\n#         \"value\": 1415168\n#       },\n#         {\n#         \"type\": \"integer\",\n#         \"key\": \"thursdayTradeStart\",\n#         \"value\": 1416068\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"thursdayTradeEnd\",\n#         \"value\": 1416608\n#       },\n#          {\n#         \"type\": \"integer\",\n#         \"key\": \"fridayTradeStart\",\n#         \"value\": 1417508\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"fridayTradeEnd\",\n#         \"value\": 1418048\n#       }\n#     ]\n#   }\n# }\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet timeOracleAddress = Address(base58'3P4V5znH4AvkpNVZ2EKSmkdSCeJppsZ4x8F')\nmatch (tx) {\n  case _:ExchangeTransaction =>\n      let mondayTradeStart = extract(getInteger(timeOracleAddress, \"mondayTradeStart\"))\n      let mondayTradeEnd = extract(getInteger(timeOracleAddress, \"mondayTradeEnd\"))\n      let tuesdayTradeStart = extract(getInteger(timeOracleAddress, \"tuesdayTradeStart\"))\n      let tuesdayTradeEnd = extract(getInteger(timeOracleAddress, \"tuesdayTradeEnd\"))\n      let wednesdayTradeStart = extract(getInteger(timeOracleAddress, \"wednesdayTradeStart\"))\n      let wednesdayTradeEnd = extract(getInteger(timeOracleAddress, \"wednesdayTradeEnd\"))\n      let thursdayTradeStart = extract(getInteger(timeOracleAddress, \"thursdayTradeStart\"))\n      let thursdayTradeEnd = extract(getInteger(timeOracleAddress, \"thursdayTradeEnd\"))\n      let fridayTradeStart = extract(getInteger(timeOracleAddress, \"fridayTradeStart\"))\n      let fridayTradeEnd = extract(getInteger(timeOracleAddress, \"fridayTradeEnd\"))\n\n      (height >= mondayTradeStart && height <= mondayTradeEnd) || (height >= tuesdayTradeStart && height <= tuesdayTradeEnd)||\n      (height >= wednesdayTradeStart && height <= wednesdayTradeEnd) || (height >= thursdayTradeStart && height <= thursdayTradeEnd)||\n      (height >= fridayTradeStart && height <= fridayTradeEnd)\n  case _ => true\n}\n","type":"ride","id":"smart-assets/ScheduleTrade.ride","sha":"371e16fdae2a0a5b3bd1e94ad7cb3b6aeba2a351","readonly":true},{"name":"Taxation.ride","content":"# This script allows to apply taxation models to assets\n# Token owners can transfer it only if they pay taxes to the issuer\n# The tax size is defined by token issuer in data transaction\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nmatch (tx) {\n    # we allow only mass transfer transactions\n    # first transfer in MassTransfer should always go to the issuer\n    case mtt:MassTransferTransaction => {\n        let firstRecipient = mtt.transfers[0].recipient\n        let firstAmount = mtt.transfers[0].amount\n        let assetId = extract(mtt.assetId)\n        let issueTransaction = transactionById(assetId)\n\n        # assetId equals to issue transaction id, so we can get issuer public key (and address) from the issue transaction\n        match(issueTransaction) {\n            case issueTx: IssueTransaction => {\n                let issuerAddress = addressFromPublicKey(issueTx.senderPublicKey)\n                # to set tax amount, issuer should make a data transaction with integer value by key matching assetId\n                let taxSize = extract(getInteger(issuerAddress, toBase58String(assetId)))\n\n                firstRecipient == issuerAddress # recipient for the first transfer should be the issuer address\n                &&\n                firstAmount >= mtt.totalAmount / 100 * taxSize # tax amount can't be less than defined in data transaction\n            }\n            case _ => false\n        }\n    }\n    case _ => false\n  }","type":"ride","id":"smart-assets/Taxation.ride","sha":"eb92f69eaa5dc8b6e78d6807fa8bf4a2acff365e","readonly":true},{"name":"VerifiedTrading.ride","content":"# Set Smart asset to trade only with BetterTokens verified assets and Waves.\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\n# BetterTokens Oracle address.\nlet addr = Address(base58'3P6t5mKGwVDkyjFhtUqw4NnecyC3DRpLfkw')\n\nmatch (tx) {\n    case e:ExchangeTransaction => \n        # Determine if Smart asset is paired with Waves.\n        let withWaves = (!isDefined(e.sellOrder.assetPair.priceAsset) || !isDefined(e.sellOrder.assetPair.amountAsset))\n\n        if(withWaves == false) then {\n            # If paired with another token, check BetterToken status.\n            #\n            # We cannot determine if Smart asset is amount or price asset in the pair\n            # that is why we check in both places.\n            let priceAssetKey = \"status_<\" + toBase58String(extract(e.sellOrder.assetPair.priceAsset)) + \">\"\n            let priceAssetInOracle = (getInteger(addr, priceAssetKey) == 2)\n\n            let amountAssetKey = \"status_<\" + toBase58String(extract(e.sellOrder.assetPair.amountAsset)) + \">\"\n            let amountAssetInOracle = (getInteger(addr, priceAssetKey) == 2)\n            \n            priceAssetInOracle || amountAssetInOracle\n        } else {\n            true\n        }\n    case _ => true\n}","type":"ride","id":"smart-assets/VerifiedTrading.ride","sha":"ebe4db16345d2a5ed9ff1d871a5f092d8444a118","readonly":true}]}],"files":{"welcome.md":{"name":"welcome.md","content":"# Waves dApps\n \n### Ride language\n\nWaves blockchain uses functional programming language based on expressions called RIDE. It is simple, yet efficient. \nPlease check [ride documentation](https://docs.wavesplatform.com/en/ride)\n\n\n### Writing dApps\n\nA dApp, or decentralised application, is an application, that executes in a distributed computer system, for instance, \nin a blockchain. In particular, Waves dApp is an application, written in RIDE language and executed on the nodes of the \nWaves blockchain. Check [writing dApps](https://docs.wavesplatform.com/en/building-apps/smart-contracts/writing-dapps)\nsection\n\n### Examples\n\nIDE contains a lot of runnable Scripts, dApps and tests to help you get used to Ride language.\nCheck them in Library menu\n\n\n### Other tools\n\nWeb IDE is just a starting point. For professional development we recommend using our offline tools.\nCheck [Professional toolkit for coding with RIDE](https://blog.wavesplatform.com/how-to-build-deploy-and-test-a-waves-ride-dapp-785311f58c2)\n\n1. [VSCode plugin](https://marketplace.visualstudio.com/items?itemName=wavesplatform.waves-ride)\n2. [Surfboard CLI tool](https://www.npmjs.com/package/@waves/surfboard)\n3. [Waves private node](https://hub.docker.com/r/wavesplatform/waves-private-node)\n\n\n### Video Tutorials          \n                                                                                   \n1. [Using Smart Contracts with Waves Console](https://www.youtube.com/watch?v=sOZuE9Ebfko&t=557s)     \n2. [Multi Signature Using Waves IDE & WavesJ](https://www.youtube.com/watch?v=o2msjSo0y0o&t=32s)      \n3. [Escrow Using Waves IDE & WavesJ](https://www.youtube.com/watch?v=31dwYcgb65M&t=381s)              \n4. [Waves Console Commands Example](https://www.youtube.com/watch?v=gBgLjg6nrvA&amp=&feature=youtu.be)\n5. [Create MultiSig Account via Waves IDE tools](https://www.youtube.com/watch?v=8DKRGnwsBjk)         \n\n\n### Hitchhiker’s Guide to Waves Smart Contracts\n\n1. [The First Part](https://blog.wavesplatform.com/the-hitchhikers-guide-to-waves-smart-contracts-part-1-b80aa47a745a)   \n2. [The Second Part](https://blog.wavesplatform.com/the-hitchhikers-guide-to-waves-smart-contracts-part-2-44621fd5a007)\n   \n   \n### Forum\n\n1.  [DevTools: IDE + REPL](https://forum.wavesplatform.com/t/devtools-ide-repl/1992)\n\nThis topic is for discussing your issues, requests, feedback and for announcements related to Waves Ride IDE and REPL\n\n","type":"md","id":"welcome.md","sha":"4d9bab57608e43e5c300503a6de305ef4005fd65","readonly":true}}}