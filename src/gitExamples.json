{"smart-accounts":[{"name":"AuthorizedTrader.ride","dir":"smart-accounts","content":"#allow trader to set orders on your account\n#this is the same as you send your api-key on common exchanges to the trader without sharing your private key or seed\n#trader is allowed to set order on certain pairs\n#order expiration time should be less then 2 minutes, as trader cannot cancel orders in current RIDE version\n#at any time accout owner can cancel\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet traderPublicKey = base58'QLMkJYFXsXiLLiKCbVCZZzQQT3whz8PAPdT7w4yQjEn'\nlet ownerPublicKey = base58'4gFmmsNv1qA9Krn3pUGbZVcJQTCsXEXhZjEtszDtxMXz'\nlet amountAsset = base58'8LLpj6yQLUu37KUt3rVo1S69j2gWMbgbM6qqgt2ac1Vb'\nlet matcherPublicKey = base58'7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy'\n\n\nmatch (tx) {\n    case o:Order =>\n        let isWavesPriceAsset = !isDefined(o.assetPair.priceAsset)\n        let rightPair = (o.assetPair.amountAsset == amountAsset) && isWavesPriceAsset\n        sigVerify(o.bodyBytes, o.proofs[0], traderPublicKey)\n        && rightPair\n        && o.expiration - o.timestamp < 120*1000\n        && o.matcherPublicKey == matcherPublicKey\n    case t:SetScriptTransaction | TransferTransaction =>\n        sigVerify(t.bodyBytes, t.proofs[0], ownerPublicKey)\n    case _ =>\n        false\n }"},{"name":"Multisig.ride","dir":"smart-accounts","content":"{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n#define public keys\nlet alicePubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'\nlet bobPubKey    = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'\nlet cooperPubKey = base58'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD'\n\n#check whoever provided the valid proof\nlet aliceSigned  = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey  )) then 1 else 0\nlet bobSigned    = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey    )) then 1 else 0\nlet cooperSigned = if(sigVerify(tx.bodyBytes, tx.proofs[2], cooperPubKey )) then 1 else 0\n\n#sum up every valid proof to get at least 2\naliceSigned + bobSigned + cooperSigned >= 2\n"},{"name":"XmasTree.ride","dir":"smart-accounts","content":"# Contract example from tradisys.com team\n\n### Prerequisites ###\n# - balance = playersPrize + dataTransactionFee * 3 + transferTransactionFee\n# - no data required\n#####################\n\n### Player's precautions ###\n# - Smart account balance is >= playersPrize + dataTransactionFee * 2 + transferTransactionFee\n# - Data on account: playersPublicKey matches player's public key, lockedAt is approximately equal to current block height.\n############################\n\n### Normal flow ###\n# 1) Data transaction from server, data = [lockedAt, playersPublicKey]. lockedAt = height or height - 1. Transition: InitialState -> LockedState\n# 2) Data transaction from player, data = [playersChoice]. Transition: LockedState -> PlayerRevealedHisChoiceState\n# 3) Transfer transaction  from player, amount = donation\n# 4) Data transaction from server, data = [serversChoice, serversSalt]. Transition: PlayerRevealedHisChoiceState -> WinnerIsDeterminedState\n# 5) Transfer transaction, recipients = winner (playersPrize + donation). Transition: PlayerDecidedNotToSendDonationState -> <InvalidState>\n###################\n\n### Emergency flow ###\n# 1) Normal flow #1 is completed, but user hasn't done any actions in timeoutInBlocks blocks - we allow server to override\n#    playersPublicKey and lockedAt data. Transition: UserDecidedNotToPlayState -> LockedState\n# 2) Normal flow #2 is completed, but server hasn't done any actions in timeoutInBlocks * 2 blocks from lockedAt - we allow player\n#    to widthdraw all the money. Transition: ServerDecidedNotToPlayState -> <InvalidState>\n# 3) Players sent his choice (Normal Flow #2), but not his money (Normal flow #3) - we allow server to withdraw all the money.\n#    Transition: PlayerDecidedNotToSendDonationState -> <InvalidState>\n######################\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n### Injected values ###\nlet serversPublicKey = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'\nlet enctyptedServersChoice = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM' # keccak256(serversChoice + serversSalt)\nlet donation = 100_000_000 # waves * 100_000_000, eq. 300000000 (= 3 waves)\nlet playersPrize = 100_000_000 # waves * 100_000_000, eq. 400000000 (= 2 waves)\nlet boxesCount = 5\n#######################\n\n### Values from data ###\nlet maybeDataPlayersPublicKey = getString(tx.sender, \"playersPublicKey\")\nlet dataPlayersPublicKey = fromBase58String(extract(maybeDataPlayersPublicKey))\nlet dataLockedAt = extract(getInteger(tx.sender, \"lockedAt\"))\nlet maybeDataPlayersChoice = getInteger(tx.sender, \"playersChoice\")\nlet dataPlayersChoice = extract(maybeDataPlayersChoice)\nlet maybeDataServersChoice = getInteger(tx.sender, \"serversChoice\")\nlet dataServersChoice = extract(maybeDataServersChoice)\n########################\n\nlet timeoutInBlocks = 120\nlet dataTransactionFee = 500000 # 0.001 + 0.004 (smart account fee)\nlet transferTransactionFee = 500000 # 0.001 + 0.004 (smart account fee)\nlet serversAddress = addressFromPublicKey(serversPublicKey)\nlet playersAddress = addressFromPublicKey(dataPlayersPublicKey)\nlet accountBalance = wavesBalance(tx.sender)\n\nlet senderIsServer = sigVerify(tx.bodyBytes, tx.proofs[0], serversPublicKey)\nlet senderIsPlayer = sigVerify(tx.bodyBytes, tx.proofs[0], dataPlayersPublicKey)\n\n### States ###\n# InitialState @ no data is deployed to account\n# Balance: playersPrize + dataTransactionFee * 3 + transferTransactionFee\nlet isInitialState = !isDefined(maybeDataPlayersPublicKey) && accountBalance >= playersPrize + dataTransactionFee * 3 + transferTransactionFee\n\n# LockedState @ account is locked for a specific player by server\n# State: playersPublicKey and lockedAt in data; height <= lockedAt + timeoutInBlocks\n# Balance: donation + dataTransactionFee * 2 + massTransferTransactionFee\nlet dataIsValidForLockedState = isDefined(maybeDataPlayersPublicKey) && !isDefined(maybeDataPlayersChoice)\nlet lockedStateTimeout = height > dataLockedAt + timeoutInBlocks\nlet isLockedState = dataIsValidForLockedState && !lockedStateTimeout\n\n# UserDecidedNotToPlayState @ user didn't send a data transaction in timeoutInBlocks blocks\nlet isUserDecidedNotToPlayState = dataIsValidForLockedState && lockedStateTimeout\n\n# PlayerRevealedHisChoiceState @ player sent a data transaction with his choice (and donationted simultaneously)\n# State: playersPublicKey, lockedAt, playersChoice in data; height <= lockedAt + timeoutInBlocks * 2\n# Balance: playersPrize (playersPrize + donation is fine too) + dataTransactionFee + transferTransactionFee\nlet dataIsValidForPlayerRevealedState = isDefined(maybeDataPlayersChoice) && !isDefined(maybeDataServersChoice)\nlet playerRevealedStateTimeout = (height > dataLockedAt + timeoutInBlocks * 2) && (accountBalance >= playersPrize + donation + dataTransactionFee + transferTransactionFee)\nlet isPlayerRevealedHisChoiceState = dataIsValidForPlayerRevealedState && !playerRevealedStateTimeout\n\n# ServerDecidedNotToPlayState @ the same as PlayerRevealedHisChoiceState, but after timeoutInBlocks * from lockedAt\n# Balance: strictly >= playersPrize + donation + dataTransactionFee + transferTransactionFee, otherwise player will be able to publish data transaction w/o transfer\nlet isServerDecidedNotToPlayState = dataIsValidForPlayerRevealedState && playerRevealedStateTimeout\n\n# WinnerIsDeterminedState @ we are ready to send money to winner\n# Balance: strictly >= playersPrize + donation + transferTransactionFee\nlet isDataValidForWinnerIsDeterminedState = isDefined(maybeDataServersChoice)\nlet isBalanceValidForWinnerIsDeterminedState = accountBalance >= playersPrize + donation + transferTransactionFee\nlet isWinnerIsDeterminedState = isDataValidForWinnerIsDeterminedState && isBalanceValidForWinnerIsDeterminedState\n\n# PlayerDecidedNotToSendDonationState @ player sent data transaction with his choice, but not a transfer transaction with donation\nlet isPlayerDecidedNotToSendDonationState = isDataValidForWinnerIsDeterminedState && !isBalanceValidForWinnerIsDeterminedState\n##############\n\nmatch (tx) {\n  case dtx:DataTransaction => (\n    let payloadSize = size(dtx.data)\n    let firstPayloadName = dtx.data[0].key\n    let secondPayloadName = dtx.data[1].key\n    let firstPayloadAsInteger = extract(getInteger(dtx.data, firstPayloadName))\n    let secondPayloadAsString = extract(getString(dtx.data, secondPayloadName))\n    let dataFeeIsOk = dtx.fee == dataTransactionFee\n\n    if (isInitialState || isUserDecidedNotToPlayState) then ( # Normal flow #1, Emergency flow #1\n        let validLockedAtIsProvided = firstPayloadName == \"lockedAt\" && (firstPayloadAsInteger <= height && height - firstPayloadAsInteger <= 5)\n        let playersPublicKeyIsProvided = secondPayloadName == \"playersPublicKey\"\n        senderIsServer && dataFeeIsOk && validLockedAtIsProvided && playersPublicKeyIsProvided && payloadSize == 2\n    ) else if (isLockedState) then ( # Normal flow #2\n        let validPlayersChoiceIsProvided = firstPayloadName == \"playersChoice\" && (firstPayloadAsInteger >= 0 && firstPayloadAsInteger < boxesCount)\n        senderIsPlayer && dataFeeIsOk && validPlayersChoiceIsProvided && payloadSize == 1\n    ) else if (isPlayerRevealedHisChoiceState) then ( # Normal flow #4\n        let validServerChoiceWasProvided = firstPayloadName == \"serversChoice\" && (firstPayloadAsInteger >= 0 && firstPayloadAsInteger < boxesCount)\n        let serversSaltWasProvided = secondPayloadName == \"serversSalt\"\n        let choiceAndSaltMatchesHardcodedValue = keccak256(toBytes(toString(firstPayloadAsInteger) + secondPayloadAsString)) == enctyptedServersChoice\n\n        senderIsServer && dataFeeIsOk && validServerChoiceWasProvided && serversSaltWasProvided && choiceAndSaltMatchesHardcodedValue && payloadSize == 2\n    ) else (\n        false \n    )\n  )\n  case ttx:TransferTransaction => (\n      let transferFeeIsOk = ttx.fee == transferTransactionFee\n\n      if (isWinnerIsDeterminedState) then ( # Normal flow #5\n        let winnerAddress = if (dataServersChoice == dataPlayersChoice) then playersAddress else serversAddress\n          let prizeGoesToWinner = ttx.recipient == winnerAddress\n\n        transferFeeIsOk && prizeGoesToWinner && ttx.amount == playersPrize + donation\n      ) else if (isServerDecidedNotToPlayState) then ( # Emergency flow #2\n        let recipientIsPlayer = ttx.recipient == playersAddress\n\n        transferFeeIsOk && recipientIsPlayer && ttx.amount == playersPrize + donation\n      ) else if (isPlayerDecidedNotToSendDonationState) then ( # Emergency flow #3\n        let recipientIsServer = ttx.recipient == serversAddress\n        transferFeeIsOk && recipientIsServer && ttx.amount == playersPrize\n      ) else (\n        false\n      )\n  )\n  case _ => false\n}\n"},{"name":"casino.ride","dir":"smart-accounts","content":"# If you want to test it on TestNet\n# You will need Keeper (Don't forget TO SWITCH IT TO TESTNET MODE!)\n# go http://185.43.6.227:8000\n# and Play\n#\n#\n# This is an account script of a roulette in a casino\n# Results of games are put into the blockchain by the Oracle periodically (every 5 minutes).\n# Oracle posts its messages to separate account \n#\n# How to make bet\n# \n# To participate you need to Transfer Waves to this account - make Payment and register the bet \n#\n# 1. Payment\n#    Just send money to the casino's account\n#\t One payment - one bet. Minimal bet amount = 0.5.\n#    Bet registration fee (see next paragraph) is substracted from your payment.\n# 2. Register payment as the bet\n#    You need to register the bet for the game round. Choose round by it's timestamp (happens every 5 minutes). \n#    To register you need send DataTransaction from the script account signed by Payment sender and containing the following data:\n#    (<payment_id>, guess), (<payment_id>_round, timestamp_of_the_round)\n# \t timestamp_of_the_round - in UTF8 encoding in bytes(13 bytes)\n#    Guess is a ByteArray in the following format:\n#     type of bet (1 byte), guess (1 byte)\n#     Bet type could be one of the following (in braces possible 'guess' values are defined):\n#     0 - number (number)\n#     1 - red (0) or black (1)\n#     2 - even (0) or odd (1)\n#     3 - 1st half of the desk (0) and 2nd half (1)\n#     4 - 1st third of the desk (0), 2nd third (1), 3rd third (2)\n#     5 - 1st row of the desk (0), 2nd row (1), 3rd row (2)\n#\n# How to get your prise in case you win \n#\n# In case you guess right you can get more money then your bet (see koeff variable in the code).\n# Formula is: (paymentTx.amount - registerBetTxFee) * koeff - dataTxsFees - withdrawTx.fee\n#\n# You win the round defined by your Bet Registration in case the Oracle\n# put equal value to the round's data. Oracle puts DataTransaction where\n#  - the key is the timestamp of the round in UTF8 format converted to ByteArray\n#  - value is ByteArray containing\n#    1) version (1 byte)\n#\t 2) wining value for bet of type0 - number (1 byte)\n#\t 3) wining value for bet of type1 - red/black (1 byte)\n#\t 4) wining value for bet of type2 - even/odd (1 byte)\n#\t 5) wining value for bet of type3 - halfs of the desk (1 byte)\n#\t 6) wining value for bet of type4 - thirds of the desk (1 byte)\n#\t 7) wining value for bet of type5 - rows of the desk (1 byte)\n#\n# You can also get your money back if you just sent Payment, but didn't register it as a bet.\n# In this case you need to do the same as described below, but amount would be the following:\n# paymentTx.amount - dataTxsFees - withdrawTx.fee \n#\n# To get money you need to do the following:\n# 1. Create withdraw - Transfer transaction. Amount of money must be calculated according to type of your bet\n#    and concider fees - fee of withdraw transaction and fees of data transactions (see 2.)\n#    Withdraw transaction must:\n#\t 1) be originated from the Casino account (sender - is the Casino account public key)\n#    2) be signed by Payment sender\n#\t 3) contain Payment transaction id in the second proof.\n#    Don't send withdraw yet, just remember it's id (<withdraw_id>). \n#\t You will send it on step 3, after the DataTransaction. \n# 2. Create and send DataTransaction. This DataTransaction links your Payment to the Withdraw.\n#    Because of this DataTransaction you only able to get money once per payment which won. \n#\t In case you sent DataTransaction but lost your Withdraw transaction (e.g. it is expired),\n#    you can provide another DataTransaction with new link of Payment to Withdraw.\n#    Since DataTransactions are made from the name of the Casino account fees \n#\t will be substracted from your prise.\n#\t DataTransaction must: \n#    1) be originated from the Casino account (sender - is the Casino account public key)\n#    2) be signed by Payment sender\n#    3) contain the following (key, value) pairs:\n#    (<payment_id>_withdraw, <withdraw_id>), (<payment_id>_withdraw_fees, sum_ammount_of_data_txs_fees)\n#\t sum_ammount_of_data_txs_fees - is sum of fees of all DataTransactions for this payment.\n# 3. When DataTransaction is in the blockchain send Withdraw created on step 1.\n#\n# Donation \n# if you find this script useful, you can donate\n# Waves address: 3P5VCmMc7fqqJijHaS3yB8jCwq7rgmLpszx\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet me = tx.sender\nlet oracle = extract(addressFromString(\"3NCzaYTNDGtR8zf9yfcqePFjCqFx9S5zhs4\"))\nlet minWithdrawFee = 500000\nlet registerBetTxFee = 500000\n\nmatch(tx) {\n\tcase withdrawTx: TransferTransaction =>\n\t\t# proofs[0] contains signiture by payment sender\n\t\t# proofs[1] contains payment Tx id\n\t\tlet txId = extract(getString(me, toBase58String(tx.proofs[1]) + \"_withdraw\"))\n\t\tmatch(transactionById(tx.proofs[1])) {\n\t\t\tcase paymentTx: TransferTransaction =>\n\t\t\t   let isPaymentTookPlace = txId == toBase58String(tx.id) && sigVerify(tx.bodyBytes, tx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\tlet feesKey = toBase58String(tx.proofs[1]) + \"_withdraw_fees\"\n\t\t\t\tlet dataTxsFees = extract(getInteger(me, feesKey))\n\n\t\t\t\tlet guessUnit = getBinary(me, toBase58String(tx.proofs[1]))\n\t\t\t\t\n\t\t\t\tlet correctAmount = if (!isDefined(guessUnit)) then\n\t\t\t\t{\n\t\t\t\t\t# return back payment\n\t\t\t\t\tpaymentTx.amount - dataTxsFees - withdrawTx.fee\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t# get win prise\n\t\t\t\t\tlet guess = extract(guessUnit)\n\n\t\t\t\t\tlet type = take(guess, 1)\n\t\t\t\t\tlet val = drop(guess, 1)\n\t\t\t\t\tlet key = extract(getString(me, toBase58String(tx.proofs[1]) + \"_round\"))\n\n\t\t\t\t\tlet valComplex = extract(getBinary(oracle, key))\n\n\t\t\t\t\tlet koeff =\n\t\t\t\t\t\tif (type == drop(toBytes(0), 7)) then 36\n\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then 3\n\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then 3\n\t\t\t\t\t\telse 0\n\n\t\t\t\t\t(paymentTx.amount - registerBetTxFee) * koeff - dataTxsFees - withdrawTx.fee\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t(isPaymentTookPlace || throw(\"There was no bet\")) \n\t\t\t\t&& \n\t\t\t\t((withdrawTx.amount == correctAmount) || throw(\"Amount is incorrect. Correct amount is \" + toString(correctAmount))) \n\t\t\t\t&& \n\t\t\t\t((!isDefined(withdrawTx.feeAssetId) && !isDefined(withdrawTx.assetId)) \n\t\t\t\t|| throw(\"Withdraw and fee must be in WAVES\"))\n\n\t\t\tcase _ => false\n\t\t}\n\n\tcase dtx: DataTransaction =>\n\n\t\tif (size(dtx.data) == 3) then\n\t\t{\n\t\t\t# Data Tx for BET REGISTRATION\n\t\t\t\t\t\t\n\t\t\tlet minBet = \t  50000000\n\t\t\tlet maxSumBet = 1000000000 # max sum bet for round\n\t\t\t\n\t\t\tlet paymentTxIdStr = extract(dtx.data[0].key)\n\t\t\t\n\t\t\tlet guessStr = extract(getString(dtx.data, paymentTxIdStr))\n\t\t\tlet paymentRoundKey = paymentTxIdStr + \"_round\"\n\t\t\tlet paymentRound = extract(getString(dtx.data, paymentRoundKey))\n\t\t\t\n\t\t\tlet sumBetsOld = if isDefined(getInteger(me, paymentRound + \"_betsSum\")) \n\t\t\t\t\t\t\t\tthen extract(getInteger(me, paymentRound + \"_betsSum\")) \n\t\t\t\t\t\t\t\telse 0\n\t\t\tlet sumBetsNew = extract(getInteger(dtx.data, paymentRound + \"_betsSum\"))\n\n\t\t\tlet itsTooLate = isDefined(getString(me, paymentRound + \"_stop\"))\n\t\t\t\n\t\t\tlet isPaymentAlreadyMentioned = isDefined(getString(me, paymentTxIdStr))\n\n\t\t\tlet paymentTx = transactionById(fromBase58String(paymentTxIdStr))\n\t\t\tmatch (paymentTx) {\n\t\t\t\tcase paymentTx : TransferTransaction =>\n\t\t\t\t\t# data-transaction must be signed by payment sender\n\t\t\t\t\tlet isDtxSignedByPayer = sigVerify(dtx.bodyBytes, dtx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\t\tlet correctSumBets = sumBetsOld + paymentTx.amount - dtx.fee # data tx fee is payed by Payment sender from its bet\n\n\t\t\t\t\t(addressFromRecipient(paymentTx.recipient) == me || throw(\"Incorrect recipient of the payment\"))\n\t\t\t\t\t&&\n\t\t\t\t\t(!isPaymentAlreadyMentioned || throw(\"This transfer is already used as a bet\")) \n\t\t\t\t\t&& \n\t\t\t\t\t((sumBetsNew == correctSumBets)\n\t\t\t\t\t|| throw(\"Wrong value for Sum of Bets. Must be \" + toString(correctSumBets)))\n\t\t\t\t\t&&\n\t\t\t\t\t((sumBetsNew < maxSumBet) \n\t\t\t\t\t|| throw(\"Maximum amount of bets for round \" + toString(maxSumBet) + \". With your bet it's \" + toString(sumBetsNew)))\n\t\t\t\t\t&&\n\t\t\t\t\t((dtx.fee == registerBetTxFee) \n\t\t\t\t\t|| throw(\"Fee of bet registration data transaction must be \" + toString(registerBetTxFee)))\n\t\t\t\t\t&&\n\t\t\t\t\t((paymentTx.amount - registerBetTxFee >= minBet) || throw(\"Your Bet amount is less then minimal bet \" + toString(minBet) + \". Payment amount for such bet must be \" + toString(minBet+registerBetTxFee)))\n\t\t\t\t\t&& \n\t\t\t\t\t((!isDefined(paymentTx.feeAssetId) || throw(\"Paymnet must be in WAVES\")))\n\t\t\t\t\t&& \n\t\t\t\t\t(!itsTooLate || throw(\"It's too late to play this round. Try next one\"))\n\n\t\t\t\t\t \n\n\t\t\t\tcase _ => false\n\t\t\t}\t\t\n\t\t}\n\t\telse if (size(dtx.data) == 2) then\n\t\t{\n\t\t\t# Data Tx for WITHDRAW registration\n\n\t\t\t# payment transaction in the first key-value.\n\t\t\t# Data tx must be signed by payment sender\n\n\t\t\tlet isDataCountOk = size(dtx.data) == 2\n\n\t\t\tlet paymentTxIdStr = dropRight(extract(dtx.data[0].key), 9) # drop \"_withdraw\"\n\t\t\tlet feesKey = paymentTxIdStr + \"_withdraw_fees\"\n\t\t\tlet paymentTx = transactionById(fromBase58String(paymentTxIdStr))\n\t\t\tlet newFees = extract(getInteger(dtx.data, feesKey))\n\t\t\tlet oldFeesUnit = getInteger(me, feesKey)\n\t\t\tlet oldFees = if isDefined(oldFeesUnit)\n\t\t\t\t\t\t\tthen extract(oldFeesUnit)\n\t\t\t\t\t\t\telse 0\n\n\t\t\tlet isFeeCorrect = newFees == oldFees + dtx.fee\n\n\t\t\t#if payment already mentioned in the State, the corresponding withdraw tx must not exist\n\t\t\t\n\t\t\tlet withdrawTxIdUnit = getString(me, paymentTxIdStr)\n\t\t\tlet isPaymentAlreadyMentioned = isDefined(withdrawTxIdUnit)\n\n\t\t\tlet withdrawTransactionId = fromBase58String(extract(withdrawTxIdUnit))\n\n\t\t\tmatch (paymentTx) {\n\t\t\t\tcase paymentTx : TransferTransaction =>\n\t\t\t\t\t# data-transaction must be signed by payment sender\n\t\t\t\t\tlet isDtxSignedByPayer = sigVerify(dtx.bodyBytes, dtx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\t\t#if payment correct\n\t\t\t\t\tif (addressFromRecipient(paymentTx.recipient) == me\n\t\t\t\t\t\t&&\n\t\t\t\t\t\t(!isPaymentAlreadyMentioned || !isDefined(transactionById(withdrawTransactionId)) ) \n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisDtxSignedByPayer\n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisFeeCorrect\n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisDataCountOk) \n\t\t\t\t\tthen\n\t\t\t\t\t\tlet guess = extract(getBinary(me, paymentTxIdStr))\n\n\t\t\t\t\t\tlet type = take(guess, 1)\n\t\t\t\t\t\tlet key = extract(getString(me, paymentTxIdStr + \"_round\"))\n\n\t\t\t\t\t\tlet valComplex = extract(getBinary(oracle, key))\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet koeff = \n\t\t\t\t\t\t\tif  \t(type == drop(toBytes(0), 7)) then 36\n\t\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then 3\n\t\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then 3\n\t\t\t\t\t\t\telse 0\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet valReal = \n\t\t\t\t\t\t\tif  \t(type == drop(toBytes(0), 7)) then drop(take(valComplex, 2), 1)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then drop(take(valComplex, 3), 2)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then drop(take(valComplex, 4), 3)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then drop(take(valComplex, 5), 4)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then drop(take(valComplex, 6), 5)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then drop(take(valComplex, 7), 6)\n\t\t\t\t\t\t\telse throw(\"Incorrect type of guess provided\")\n\n\t\t\t\t\t\tlet isWin = drop(guess, 1) == valReal\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet isMoneyStillEnough = newFees < (paymentTx.amount - registerBetTxFee) * koeff + minWithdrawFee\n\n\t\t\t\t\t\t(isWin || throw(\"You didn't guess\")) \n\t\t\t\t\t\t&& \n\t\t\t\t\t\t(isMoneyStillEnough || throw(\"Not enough money for withdraw\")) \n\n\t\t\t\t\telse false\n\t\t\t\t\t\n\t\t\t\tcase _ => false\n\t\t\t}\n\t\t}\n\t\telse \n\t\t\tfalse\n\t\t\n\tcase _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)\n\n}\n"},{"name":"guess.ride","dir":"smart-accounts","content":"# in the state of this account, there are two fields  \n# \"question\" - with some question and \n# \"hashed answer\" - with an answer to this question \n# which is hashed by keccak256 algorithm user can send \n# any number of WAVES from this account if he/she has \n# a correct answer in an attachment of TransferTransaction  \n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet this=extract(tx.sender)\n\nmatch(tx)\n{\n    case t : TransferTransaction =>\n        let correctAnswer = extract(getBinary(this, \"hashed answer\"))\n        let answer = keccak256(t.attachment)\n\n        correctAnswer == answer \n        && !isDefined(t.assetId)\n    case s: SetScriptTransaction | DataTransaction =>\n        sigVerify(s.bodyBytes, s.proofs[0], s.senderPublicKey)\n    case _ => false\n}\n"}],"smart-assets":[{"name":"FixedPriceTicket.ride","dir":"smart-assets","content":"# This token represents a ticket that can be traded at face value only.\n#\n# Token price is hard coded into the script, and exchange is allowed\n# only at that price. Such a token can be useful for show or sport\n# tickets to help combat ticketing fraud.\n#\n# Additional restriction: a ticket can be burnt only after the show is over.\n#\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet expiration = 1552064400000  # March 8 2019, 8pm Moscow time\nlet price = 1000000000          # 10 WAVES\nmatch tx {\n    case e: ExchangeTransaction =>\n        let pair = e.buyOrder.assetPair\n        let tradedForWaves = ! isDefined(pair.amountAsset) ||\n                             ! isDefined(pair.priceAsset)\n        tradedForWaves && e.price == price\n    case b: BurnTransaction =>\n        b.timestamp > expiration\n    case _: TransferTransaction | MassTransferTransaction => true\n    case _  => false\n}\n"},{"name":"FixedRateExchange.ride","dir":"smart-assets","content":"# This token can be bought/sold for WAVES only at a rate published by\n# asset issuer.\n#\n# The issuer publishes the exchange rate with a data transaction on his\n# account. The actual exchange rate must match the published rate up to\n# 7th significant digit.\n#\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet issuer = Address(base58'3issuerAddress')\nlet assetId = base58'ThisAsset1d'\nmatch tx {\n    case ex: ExchangeTransaction =>\n        let pair = AssetPair(assetId, unit)\n        let rate = extract(getInteger(issuer, \"exchangeRate\"))\n        let rateDiff = rate - fraction(100000000, ex.price, ex.amount)\n        ex.buyOrder.assetPair == pair && rateDiff > -100 && rateDiff < 100\n    case _ => true\n}\n"},{"name":"HotPotatoToken.ride","dir":"smart-assets","content":"# This is a token-game\n# When you receive this token, you have 5000 blocks to transfer it to somebody else,\n# after that 5000 blocks you will have to pay the fee more than 1 Waves to transfer it.\n# you have to pay 10 Waves as fee to burn it, you can transfer it only to an account with >10 Waves\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet minimumWavesBalance = 10_00_000_000\nlet moveTimeInBlocks = 5000\nlet minimalFeeToMove = 1_0_000_000\nlet minimalFeeToBurn = 5_0_000_000\n\nmatch (tx) {\n    case t:TransferTransaction => {\n\n        # to get a height of blockchain when HotPotato was received we expect transaction id\n        # of incoming transfer transaction in the attachment\n        let txId = t.attachment\n\n        # script can check that current recipient doesnt hold HotPotato\n        # but not now :)\n\n        # let currentRecipientBalance = assetBalance(t.recipient, t.assetId)\n        let currentRecipientWavesBalance = wavesBalance(t.recipient)\n\n        # assetId equals to issue transaction id, so we can get issuer public key (and address) from the issue transaction\n        let transaction = transactionById(extract(t.assetId))\n\n        match (transaction) {\n            case issueTx:IssueTransaction => {\n                # issuer is allowed to send tokens without any additional requirements except signature and recipient Waves balance (should be >= 10)\n                let transactionByIssuer = t.senderPublicKey == issueTx.senderPublicKey\n                if (transactionByIssuer) then {\n                    if (currentRecipientWavesBalance < minimumWavesBalance) then {\n                        throw(\"Current balance is less than minimalWavesBalance\")\n                    }else {\n                        true\n                    }\n                }else if (size(t.attachment) < 32) then {\n                    throw(\"Attachment should contain transaction id \")\n                }else{\n                    # getting incoming transaction by id (from the attachment)\n                    let receiveTx = transactionById(txId)\n                    match (receiveTx) {\n                        case recTx:TransferTransaction | MassTransferTransaction => {\n                            # get the number of block when address get a potato\n                            let receivedBlockNumber = extract(transactionHeightById(recTx.id))\n                            # check that we received assets in allowed span\n                            let receivedAssetInLastNBlocks = (height - receivedBlockNumber) <= moveTimeInBlocks && t.assetId == recTx.assetId\n                            let feeMore1Waves = t.fee >= minimalFeeToMove\n                            if (!receivedAssetInLastNBlocks && !feeMore1Waves) then {\n                                throw(\"You got potato long time ago, now you have to pay 1 WAVES fee\")\n                            }else {\n                                receivedAssetInLastNBlocks || feeMore1Waves\n                            }\n                        }\n                        case _ => throw(\"Receive tx should be a transfer\")\n                    }\n                }\n            }\n            case _ => throw(\"Not issue tx\")\n        }\n    }\n    # we allow to burn a token only if fee > 5 waves\n    case burn: BurnTransaction => {\n        if (burn.fee < minimalFeeToBurn) then {\n            throw(\"You have to pay 5 WAVES to burn this token\")\n        }else{\n            true\n        }\n    }\n    # MassTransfer and SetAssetScript transactions are allowed only for issuer\n    case mass: MassTransferTransaction | SetAssetScriptTransaction => {\n        let transaction = transactionById(extract(mass.assetId))\n\n        match (transaction) {\n            case issueTx:IssueTransaction => {\n                mass.senderPublicKey == issueTx.senderPublicKey\n            }\n            case _ => throw(\"Bad issue tx type\")\n        }\n    }\n    case _ => throw(\"You only can transfer this token\")\n  }"},{"name":"LicenseToTrade.ride","dir":"smart-assets","content":"# For example you want to create an asset that can be traded only by those clients who have some special asset as a license\n# So you can regulate who is able to trade your token or it may be usefull in games,\n# sending this token can give the character an ability to trade or perform other skills\n# or amount of this token can imitate the health points of the players, so you can \"trade\" only if you are alive:)\n#\n# In this script case you can buy or sell SmartAsset only if your WavesCommunity token balance is greater then 10\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet WCTlicenseToTradeAsset = base58'2CjLFYkp4W4sEAxCjFG9oD3smfhvV6yQnNmiJyexbLdu'\nmatch (tx) {\n    case tx:ExchangeTransaction =>\n        assetBalance(tx.sellOrder.sender, WCTlicenseToTradeAsset) > 10_00 && assetBalance(tx.buyOrder.sender, WCTlicenseToTradeAsset) > 10_00\n    case _ => true\n}"},{"name":"MainCoinsTrade.ride","dir":"smart-assets","content":"\n# You can disable transfer, masstransfer and burn of the token,\n# Also you can define in what pairs your token can be traded.\n# This token can be traded only with BTC/ETH/LTC/ZEC/DASH/XMR/USD/EUR price assets\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet BTCId = base58'8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS'\nlet ETHId = base58'474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu'\nlet LTCId = base58'HZk1mbfuJpmxU1Fs4AX5MWLVYtctsNcg6e2C6VKqK8zk'\nlet ZECId = base58'BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa'\nlet DASHId = base58'B3uGHFRpSUuGEDWjqB9LWWxafQj8VTvpMucEyoxzws5H'\nlet XMRId = base58'5WvPKSJXzVE2orvbkJ8wsQmmQKqTv9sGBPksV4adViw3'\nlet USDId = base58'Ft8X1v1LTa1ABafufpaCWyVj8KkaxUWE6xBhW6sNFJck'\nlet EURId = base58'Gtb1WRznfchDnTh37ezoDTJ4wcoKaRsKqKjJjy7nm2zU'\n\nmatch tx {\n  case e : ExchangeTransaction =>\n    e.sellOrder.assetPair.priceAsset == BTCId || e.sellOrder.assetPair.priceAsset == ETHId || e.sellOrder.assetPair.priceAsset == LTCId || e.sellOrder.assetPair.priceAsset == ZECId || e.sellOrder.assetPair.priceAsset == DASHId || e.sellOrder.assetPair.priceAsset == XMRId || e.sellOrder.assetPair.priceAsset == USDId || e.sellOrder.assetPair.priceAsset == EURId\n  case t:TransferTransaction | MassTransferTransaction | BurnTransaction => false\n  case _ => true\n}"},{"name":"Medal.ride","dir":"smart-assets","content":"# This is a medal token.\n#\n# Medals are awarded to people using Transfer or MassTransfer. The issuer\n# can mint new medals or burn unused ones. The medal asset should have\n# zero decimals.\n#\n# A person who's awarded a medal can not transfer nor sell it,\n# but can give it back to the issuer.\n#\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet master = addressFromString(\"3masterAddress\")\nmatch tx {\n    case t: TransferTransaction =>\n        t.sender == master || t.recipient == master\n    case mt: MassTransferTransaction =>\n        mt.sender == master\n    case ex: ExchangeTransaction => false\n    case _ => true\n}\n"},{"name":"RecipientSignature.ride","dir":"smart-assets","content":"\n# General idea of this token is to allow transfer only with recipient's permisson. \n# Token ownership can be used as a proof of physycal object ownership and token transfer as a proof of 'real world' object transfer.\n\n# To use this token:\n# 1. Sender creates tx without proof and sends it to recipient\n# 2. Recipient calculates signature, adds his public key and signature to attachment field. Sends tx back to sender.\n# 3. Sender signs tx with attachment. Tx can now be sent to blockchain\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\n# Set network byte. 87 for mainnet\nlet NETWORKBYTE = takeRight(toBytes(87), 1)\n\nmatch (tx) {\n    # Only allow transfer transactions\n    case t:TransferTransaction => {\n        # Since smart assets don't have access to proofs, attachment is used, but attachment is also signed.\n        # For that reason we will verify signature against tx without attachment\n        let txWithoutAttachment = dropRight(t.bodyBytes, 97) + takeRight(toBytes(0), 1)\n\n        # Attachment contains recipient public key and signature\n        let recipientPublicKeyAndSignature = t.attachment\n        let recipientPublicKey = take(recipientPublicKeyAndSignature, 32)\n        let recipientSignature = takeRight(recipientPublicKeyAndSignature, 64)\n\n        # Get recipient address from public key in attachment\n        let recipientPublicKeyHash = take(keccak256(blake2b256(recipientPublicKey)), 20)\n        let rpkWithVersionAndByte = takeRight(toBytes(1), 1) + NETWORKBYTE + recipientPublicKeyHash\n        let checksum = take(keccak256(blake2b256(rpkWithVersionAndByte)), 4)\n        let recipientAddressFromPublicKey = rpkWithVersionAndByte + checksum\n        let recipientAddressFromTx = addressFromRecipient(t.recipient).bytes\n        \n        # Verify that tx.recipient equals recipient from attsachment\n        if (recipientAddressFromPublicKey != recipientAddressFromTx) then throw(\n            \"Recipient address error:\" + toBase58String(recipientAddressFromPublicKey)\n            ) else {\n        # Verify recipient signature\n        if (!sigVerify(txWithoutAttachment, recipientSignature, recipientPublicKey))  then  throw(\n            \"Invaid recipient signature:\" + toBase58String(recipientSignature) + \"\\n BodyBytes:\" + toBase64String(txWithoutAttachment)\n            ) else {\n            true\n        }}\n    }\n    # No exchange or masstransfer\n    case _ => false\n  }\n"},{"name":"ScheduleTrade.ride","dir":"smart-assets","content":"\n# Also you can issue an asset that can be traded on DEX only according with some schedule.\n# For example every day from 10 to 19 oâ€™clock, from monday to friday, like on real exchanges.\n\n# First of all you have to publish a data transaction with a schedule for the next week timestamps,\n# and renew it every week (it is possible to automate this task with a cron script)\n\n# This is the example of data transactions with a an approximate height from 10 to 19 o'clock from 25 February to the 1st of March:\n# You can issue an asset that will verify that current blockchain height is between tradeStart and tradeEnd\n# Example or data TX:\n\n# {\n#   \"type\": 12,\n#   \"data\": {\n#     \"fee\": {\n#       \"assetId\": \"WAVES\",\n#       \"tokens\": \"0.005\"\n#     },\n#     \"data\": [\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"mondayTradeStart\",\n#         \"value\": 1411748\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"mondayTradeEnd\",\n#         \"value\": 1412288\n#       },\n#         {\n#         \"type\": \"integer\",\n#         \"key\": \"tuesdayTradeStart\",\n#         \"value\": 1413188\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"tuesdayTradeEnd\",\n#         \"value\": 1413728\n#       },\n#\n#         {\n#         \"type\": \"integer\",\n#         \"key\": \"wednesdayTradeStart\",\n#         \"value\": 1414628\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"wednesdayTradeEnd\",\n#         \"value\": 1415168\n#       },\n#         {\n#         \"type\": \"integer\",\n#         \"key\": \"thursdayTradeStart\",\n#         \"value\": 1416068\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"thursdayTradeEnd\",\n#         \"value\": 1416608\n#       },\n#          {\n#         \"type\": \"integer\",\n#         \"key\": \"fridayTradeStart\",\n#         \"value\": 1417508\n#       },\n#       {\n#         \"type\": \"integer\",\n#         \"key\": \"fridayTradeEnd\",\n#         \"value\": 1418048\n#       }\n#     ]\n#   }\n# }\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nlet timeOracleAddress = Address(base58'3P4V5znH4AvkpNVZ2EKSmkdSCeJppsZ4x8F')\nmatch (tx) {\n  case tx:ExchangeTransaction =>\n      let mondayTradeStart = extract(getInteger(timeOracleAddress, \"mondayTradeStart\"))\n      let mondayTradeEnd = extract(getInteger(timeOracleAddress, \"mondayTradeEnd\"))\n      let tuesdayTradeStart = extract(getInteger(timeOracleAddress, \"tuesdayTradeStart\"))\n      let tuesdayTradeEnd = extract(getInteger(timeOracleAddress, \"tuesdayTradeEnd\"))\n      let wednesdayTradeStart = extract(getInteger(timeOracleAddress, \"wednesdayTradeStart\"))\n      let wednesdayTradeEnd = extract(getInteger(timeOracleAddress, \"wednesdayTradeEnd\"))\n      let thursdayTradeStart = extract(getInteger(timeOracleAddress, \"thursdayTradeStart\"))\n      let thursdayTradeEnd = extract(getInteger(timeOracleAddress, \"thursdayTradeEnd\"))\n      let fridayTradeStart = extract(getInteger(timeOracleAddress, \"fridayTradeStart\"))\n      let fridayTradeEnd = extract(getInteger(timeOracleAddress, \"fridayTradeEnd\"))\n\n      (height >= mondayTradeStart && height <= mondayTradeEnd) || (height >= tuesdayTradeStart && height <= tuesdayTradeEnd)||\n      (height >= wednesdayTradeStart && height <= wednesdayTradeEnd) || (height >= thursdayTradeStart && height <= thursdayTradeEnd)||\n      (height >= fridayTradeStart && height <= fridayTradeEnd)\n  case _ => true\n}"},{"name":"Taxation.ride","dir":"smart-assets","content":"# This script allows to apply taxation models to assets\n# Token owners can transfer it only if they pay taxes to the issuer\n# The tax size is defined by token issuer in data transaction\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\nmatch (tx) {\n    # we allow only mass transfer transactions\n    # first transfer in MassTransfer should always go to the issuer\n    case mtt:MassTransferTransaction => {\n        let firstRecipient = mtt.transfers[0].recipient\n        let firstAmount = mtt.transfers[0].amount\n        let assetId = extract(mtt.assetId)\n        let issueTransaction = transactionById(assetId)\n\n        # assetId equals to issue transaction id, so we can get issuer public key (and address) from the issue transaction\n        match(issueTransaction) {\n            case issueTx: IssueTransaction => {\n                let issuerAddress = addressFromPublicKey(issueTx.senderPublicKey)\n                # to set tax amount, issuer should make a data transaction with integer value by key matching assetId\n                let taxSize = extract(getInteger(issuerAddress, toBase58String(assetId)))\n\n                firstRecipient == issuerAddress # recipient for the first transfer should be the issuer address\n                &&\n                firstAmount >= mtt.totalAmount / 100 * taxSize # tax amount can't be less than defined in data transaction\n            }\n            case _ => false\n        }\n    }\n    case _ => false\n  }"},{"name":"VerifiedTrading.ride","dir":"smart-assets","content":"# Set Smart asset to trade only with BetterTokens verified assets and Waves.\n\n{-# STDLIB_VERSION 2 #-}\n{-# CONTENT_TYPE EXPRESSION #-}\n{-# SCRIPT_TYPE ASSET #-}\n\n# BetterTokens Oracle address.\nlet addr = Address(base58'3P6t5mKGwVDkyjFhtUqw4NnecyC3DRpLfkw')\n\nmatch (tx) {\n    case e:ExchangeTransaction => \n        # Determine if Smart asset is paired with Waves.\n        let withWaves = (!isDefined(e.sellOrder.assetPair.priceAsset) || !isDefined(e.sellOrder.assetPair.amountAsset))\n\n        if(withWaves == false) then {\n            # If paired with another token, check BetterToken status.\n            #\n            # We cannot determine if Smart asset is amount or price asset in the pair\n            # that is why we check in both places.\n            let priceAssetKey = \"status_<\" + toBase58String(extract(e.sellOrder.assetPair.priceAsset)) + \">\"\n            let priceAssetInOracle = (getInteger(addr, priceAssetKey) == 2)\n\n            let amountAssetKey = \"status_<\" + toBase58String(extract(e.sellOrder.assetPair.amountAsset)) + \">\"\n            let amountAssetInOracle = (getInteger(addr, priceAssetKey) == 2)\n            \n            priceAssetInOracle || amountAssetInOracle\n        } else {\n            true\n        }\n    case _ => true\n}"}],"ride4dapps":[{"name":"fomo.ride","dir":"ride4dapps","content":"{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\nlet lpKey = \"lastPayment\"\nlet liKey = \"bestFomoer\"\nlet lhKey = \"height\"\nlet day = 1440\n\n@Callable(i)\nfunc fearmissing() = {\n   let payment = match i.payment {\n\t   case p:AttachedPayment =>\n\t   \t\tmatch p.assetId  {\n\t\t\t\t   case assetId: ByteVector => throw(\"fomo waves only\")\n\t\t\t\t   case _ => p.amount\n\t\t\t   }\n\n\t   case _ => throw(\"payment must be attached\")\n   }\n\tlet lastPayment = match getInteger(this, \"lastPayment\") {\n\t\tcase p:Int => p\n\t\tcase _ => 0\n\t}\n\n\tif(payment <= lastPayment)\n\t\tthen throw(\"min payment is \" +toString(payment))\n\t\telse # storing best payment, caller and height\n\t\t\tWriteSet([\n\t\t\t\tDataEntry(lpKey, payment),\n\t\t\t\tDataEntry(liKey, i.caller.bytes),\n\t\t\t\tDataEntry(lhKey, height)\n\t\t\t])\n}\n\n@Callable(i)\nfunc withdraw() = {\n\tlet callerCorrect = i.caller.bytes == extract(getBinary(this, liKey))\n\tlet heightCorrect = extract(getInteger(this, lhKey)) - height >= day\n\tlet canWithdraw = heightCorrect && callerCorrect\n\n\tif (canWithdraw)\n\t\tthen TransferSet([ScriptTransfer(i.caller, wavesBalance(this), unit)])\n\t\telse throw(\"behold\")\n}\n"},{"name":"wallet.ride","dir":"ride4dapps","content":"# In this example multiple accounts can deposit their funds and safely take them back, no one can interfere with this.\n# An inner state is maintained as mapping `address=>waves`.\n\n# You can try this contract by following commands in the IDE (ide.wavesplatform.com)\n# Run commands as listed below\n# From account #0:\n#      broadcast(transfer({recipient:address(env.accounts[1]), amount: 1000000000}))\n#      broadcast(transfer({recipient:address(env.accounts[2]), amount: 1000000000}))\n# From account #1:\n#      deploy()\n# From account #2:\n#      broadcast(invokeScript({contractAddress: address(env.accounts[1]), call:{function:\"deposit\",args:[]}, payment: [{amount: 300000000, asset:null }]}))\n#      # observe state and balance of account(1)\n#      broadcast(invokeScript({contractAddress: address(env.accounts[1]), call:{function:\"deposit\",args:[]}, payment: [{amount: 200000000, asset:null }]}))\n#      # observe state and balance of account(1)\n#      broadcast(invokeScript({contractAddress: address(env.accounts[1]), call:{function:\"withdraw\",args:[{type:\"integer\", value: 600000000}]}, payment: []}))\n#      # observe error, nothing changed\n#      broadcast(invokeScript({contractAddress: address(env.accounts[1]), call:{function:\"withdraw\",args:[{type:\"integer\", value: 400000000}]}, payment: []}))\n#      # observe state and balance of account(1)\n\n\n{-# STDLIB_VERSION 3 #-}\n{-# CONTENT_TYPE DAPP #-}\n{-# SCRIPT_TYPE ACCOUNT #-}\n\n@Callable(i)\nfunc deposit() = {\n   let pmt = extract(i.payment)\n   if (isDefined(pmt.assetId)) then throw(\"can hodl waves only at the moment\")\n   else {\n        let currentKey = toBase58String(i.caller.bytes)\n        let currentAmount = match getInteger(this, currentKey) {\n            case a:Int => a\n            case _ => 0\n        }\n        let newAmount = currentAmount + pmt.amount\n        WriteSet([DataEntry(currentKey, newAmount)])\n   }\n}\n\n@Callable(i)\nfunc withdraw(amount: Int) = {\n        let currentKey = toBase58String(i.caller.bytes)\n        let currentAmount = match getInteger(this, currentKey) {\n            case a:Int => a\n            case _ => 0\n        }\n        let newAmount = currentAmount - amount\n     if (amount < 0)\n            then throw(\"Can't withdraw negative amount\")\n    else if (newAmount < 0)\n            then throw(\"Not enough balance\")\n            else ScriptResult(\n                    WriteSet([DataEntry(currentKey, newAmount)]),\n                    TransferSet([ScriptTransfer(i.caller, amount, unit)])\n                )\n    }\n\n\n@Verifier(tx)\nfunc verify() = {\n    true\n}\n"}]}