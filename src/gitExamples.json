{"smart-accounts":[{"name":"AuthorizedTrader.ride","dir":"smart-accounts","content":"#allow trader to set orders on your account\n#this is the same as you send your api-key on common exchanges to the trader without sharing your private key or seed\n#trader is allowed to set order on certain pairs\n#order expiration time should be less then 2 minutes, as trader cannot cancel orders in current RIDE version\n#at any time accout owner can cancel\n\nlet traderPublicKey = base58'QLMkJYFXsXiLLiKCbVCZZzQQT3whz8PAPdT7w4yQjEn'\nlet ownerPublicKey = base58'4gFmmsNv1qA9Krn3pUGbZVcJQTCsXEXhZjEtszDtxMXz'\nlet amountAsset = base58'8LLpj6yQLUu37KUt3rVo1S69j2gWMbgbM6qqgt2ac1Vb'\nlet matcherPublicKey = base58'7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy'\n\n\nmatch (tx) {\n    case o:Order =>\n        let isWavesPriceAsset = !isDefined(o.assetPair.priceAsset)\n        let rightPair = (o.assetPair.amountAsset == amountAsset) && isWavesPriceAsset\n        sigVerify(o.bodyBytes, o.proofs[0], traderPublicKey)\n        && rightPair\n        && o.expiration - o.timestamp < 120*1000\n        && o.matcherPublicKey == matcherPublicKey\n    case t:SetScriptTransaction | TransferTransaction =>\n        sigVerify(t.bodyBytes, t.proofs[0], ownerPublicKey)\n    case _ =>\n        false\n }"},{"name":"Multisig.ride","dir":"smart-accounts","content":"#define public keys\nlet alicePubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'\nlet bobPubKey    = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'\nlet cooperPubKey = base58'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD'\n\n#check whoever provided the valid proof\nlet aliceSigned  = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey  )) then 1 else 0\nlet bobSigned    = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey    )) then 1 else 0\nlet cooperSigned = if(sigVerify(tx.bodyBytes, tx.proofs[2], cooperPubKey )) then 1 else 0\n\n#sum up every valid proof to get at least 2\naliceSigned + bobSigned + cooperSigned >= 2\n"},{"name":"XmasTree.ride","dir":"smart-accounts","content":"# Contract example from tradisys.com team\n\n### Prerequisites ###\n# - balance = playersPrize + dataTransactionFee * 3 + transferTransactionFee\n# - no data required\n#####################\n\n### Player's precautions ###\n# - Smart account balance is >= playersPrize + dataTransactionFee * 2 + transferTransactionFee\n# - Data on account: playersPublicKey matches player's public key, lockedAt is approximately equal to current block height.\n############################\n\n### Normal flow ###\n# 1) Data transaction from server, data = [lockedAt, playersPublicKey]. lockedAt = height or height - 1. Transition: InitialState -> LockedState\n# 2) Data transaction from player, data = [playersChoice]. Transition: LockedState -> PlayerRevealedHisChoiceState\n# 3) Transfer transaction  from player, amount = donation\n# 4) Data transaction from server, data = [serversChoice, serversSalt]. Transition: PlayerRevealedHisChoiceState -> WinnerIsDeterminedState\n# 5) Transfer transaction, recipients = winner (playersPrize + donation). Transition: PlayerDecidedNotToSendDonationState -> <InvalidState>\n###################\n\n### Emergency flow ###\n# 1) Normal flow #1 is completed, but user hasn't done any actions in timeoutInBlocks blocks - we allow server to override\n#    playersPublicKey and lockedAt data. Transition: UserDecidedNotToPlayState -> LockedState\n# 2) Normal flow #2 is completed, but server hasn't done any actions in timeoutInBlocks * 2 blocks from lockedAt - we allow player\n#    to widthdraw all the money. Transition: ServerDecidedNotToPlayState -> <InvalidState>\n# 3) Players sent his choice (Normal Flow #2), but not his money (Normal flow #3) - we allow server to withdraw all the money.\n#    Transition: PlayerDecidedNotToSendDonationState -> <InvalidState>\n######################\n\n### Injected values ###\nlet serversPublicKey = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'\nlet enctyptedServersChoice = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM' # keccak256(serversChoice + serversSalt)\nlet donation = 100_000_000 # waves * 100_000_000, eq. 300000000 (= 3 waves)\nlet playersPrize = 100_000_000 # waves * 100_000_000, eq. 400000000 (= 2 waves)\nlet boxesCount = 5\n#######################\n\n### Values from data ###\nlet maybeDataPlayersPublicKey = getString(tx.sender, \"playersPublicKey\")\nlet dataPlayersPublicKey = fromBase58String(extract(maybeDataPlayersPublicKey))\nlet dataLockedAt = extract(getInteger(tx.sender, \"lockedAt\"))\nlet maybeDataPlayersChoice = getInteger(tx.sender, \"playersChoice\")\nlet dataPlayersChoice = extract(maybeDataPlayersChoice)\nlet maybeDataServersChoice = getInteger(tx.sender, \"serversChoice\")\nlet dataServersChoice = extract(maybeDataServersChoice)\n########################\n\nlet timeoutInBlocks = 120\nlet dataTransactionFee = 500000 # 0.001 + 0.004 (smart account fee)\nlet transferTransactionFee = 500000 # 0.001 + 0.004 (smart account fee)\nlet serversAddress = addressFromPublicKey(serversPublicKey)\nlet playersAddress = addressFromPublicKey(dataPlayersPublicKey)\nlet accountBalance = wavesBalance(tx.sender)\n\nlet senderIsServer = sigVerify(tx.bodyBytes, tx.proofs[0], serversPublicKey)\nlet senderIsPlayer = sigVerify(tx.bodyBytes, tx.proofs[0], dataPlayersPublicKey)\n\n### States ###\n# InitialState @ no data is deployed to account\n# Balance: playersPrize + dataTransactionFee * 3 + transferTransactionFee\nlet isInitialState = !isDefined(maybeDataPlayersPublicKey) && accountBalance >= playersPrize + dataTransactionFee * 3 + transferTransactionFee\n\n# LockedState @ account is locked for a specific player by server\n# State: playersPublicKey and lockedAt in data; height <= lockedAt + timeoutInBlocks\n# Balance: donation + dataTransactionFee * 2 + massTransferTransactionFee\nlet dataIsValidForLockedState = isDefined(maybeDataPlayersPublicKey) && !isDefined(maybeDataPlayersChoice)\nlet lockedStateTimeout = height > dataLockedAt + timeoutInBlocks\nlet isLockedState = dataIsValidForLockedState && !lockedStateTimeout\n\n# UserDecidedNotToPlayState @ user didn't send a data transaction in timeoutInBlocks blocks\nlet isUserDecidedNotToPlayState = dataIsValidForLockedState && lockedStateTimeout\n\n# PlayerRevealedHisChoiceState @ player sent a data transaction with his choice (and donationted simultaneously)\n# State: playersPublicKey, lockedAt, playersChoice in data; height <= lockedAt + timeoutInBlocks * 2\n# Balance: playersPrize (playersPrize + donation is fine too) + dataTransactionFee + transferTransactionFee\nlet dataIsValidForPlayerRevealedState = isDefined(maybeDataPlayersChoice) && !isDefined(maybeDataServersChoice)\nlet playerRevealedStateTimeout = (height > dataLockedAt + timeoutInBlocks * 2) && (accountBalance >= playersPrize + donation + dataTransactionFee + transferTransactionFee)\nlet isPlayerRevealedHisChoiceState = dataIsValidForPlayerRevealedState && !playerRevealedStateTimeout\n\n# ServerDecidedNotToPlayState @ the same as PlayerRevealedHisChoiceState, but after timeoutInBlocks * from lockedAt\n# Balance: strictly >= playersPrize + donation + dataTransactionFee + transferTransactionFee, otherwise player will be able to publish data transaction w/o transfer\nlet isServerDecidedNotToPlayState = dataIsValidForPlayerRevealedState && playerRevealedStateTimeout\n\n# WinnerIsDeterminedState @ we are ready to send money to winner\n# Balance: strictly >= playersPrize + donation + transferTransactionFee\nlet isDataValidForWinnerIsDeterminedState = isDefined(maybeDataServersChoice)\nlet isBalanceValidForWinnerIsDeterminedState = accountBalance >= playersPrize + donation + transferTransactionFee\nlet isWinnerIsDeterminedState = isDataValidForWinnerIsDeterminedState && isBalanceValidForWinnerIsDeterminedState\n\n# PlayerDecidedNotToSendDonationState @ player sent data transaction with his choice, but not a transfer transaction with donation\nlet isPlayerDecidedNotToSendDonationState = isDataValidForWinnerIsDeterminedState && !isBalanceValidForWinnerIsDeterminedState\n##############\n\nmatch (tx) {\n  case dtx:DataTransaction => (\n    let payloadSize = size(dtx.data)\n    let firstPayloadName = dtx.data[0].key\n    let secondPayloadName = dtx.data[1].key\n    let firstPayloadAsInteger = extract(getInteger(dtx.data, firstPayloadName))\n    let secondPayloadAsString = extract(getString(dtx.data, secondPayloadName))\n    let dataFeeIsOk = dtx.fee == dataTransactionFee\n\n    if (isInitialState || isUserDecidedNotToPlayState) then ( # Normal flow #1, Emergency flow #1\n        let validLockedAtIsProvided = firstPayloadName == \"lockedAt\" && (firstPayloadAsInteger <= height && height - firstPayloadAsInteger <= 5)\n        let playersPublicKeyIsProvided = secondPayloadName == \"playersPublicKey\"\n        senderIsServer && dataFeeIsOk && validLockedAtIsProvided && playersPublicKeyIsProvided && payloadSize == 2\n    ) else if (isLockedState) then ( # Normal flow #2\n        let validPlayersChoiceIsProvided = firstPayloadName == \"playersChoice\" && (firstPayloadAsInteger >= 0 && firstPayloadAsInteger < boxesCount)\n        senderIsPlayer && dataFeeIsOk && validPlayersChoiceIsProvided && payloadSize == 1\n    ) else if (isPlayerRevealedHisChoiceState) then ( # Normal flow #4\n        let validServerChoiceWasProvided = firstPayloadName == \"serversChoice\" && (firstPayloadAsInteger >= 0 && firstPayloadAsInteger < boxesCount)\n        let serversSaltWasProvided = secondPayloadName == \"serversSalt\"\n        let choiceAndSaltMatchesHardcodedValue = keccak256(toBytes(toString(firstPayloadAsInteger) + secondPayloadAsString)) == enctyptedServersChoice\n\n        senderIsServer && dataFeeIsOk && validServerChoiceWasProvided && serversSaltWasProvided && choiceAndSaltMatchesHardcodedValue && payloadSize == 2\n    ) else (\n        false \n    )\n  )\n  case ttx:TransferTransaction => (\n      let transferFeeIsOk = ttx.fee == transferTransactionFee\n\n      if (isWinnerIsDeterminedState) then ( # Normal flow #5\n        let winnerAddress = if (dataServersChoice == dataPlayersChoice) then playersAddress else serversAddress\n          let prizeGoesToWinner = ttx.recipient == winnerAddress\n\n        transferFeeIsOk && prizeGoesToWinner && ttx.amount == playersPrize + donation\n      ) else if (isServerDecidedNotToPlayState) then ( # Emergency flow #2\n        let recipientIsPlayer = ttx.recipient == playersAddress\n\n        transferFeeIsOk && recipientIsPlayer && ttx.amount == playersPrize + donation\n      ) else if (isPlayerDecidedNotToSendDonationState) then ( # Emergency flow #3\n        let recipientIsServer = ttx.recipient == serversAddress\n        transferFeeIsOk && recipientIsServer && ttx.amount == playersPrize\n      ) else (\n        false\n      )\n  )\n  case _ => false\n}\n"},{"name":"casino.ride","dir":"smart-accounts","content":"# If you want to test it on TestNet\n# You will need Keeper (Don't forget TO SWITCH IT TO TESTNET MODE!)\n# go http://185.43.6.227:8000\n# and Play\n#\n#\n# This is an account script of a roulette in a casino\n# Results of games are put into the blockchain by the Oracle periodically (every 5 minutes).\n# Oracle posts its messages to separate account \n#\n# How to make bet\n# \n# To participate you need to Transfer Waves to this account - make Payment and register the bet \n#\n# 1. Payment\n#    Just send money to the casino's account\n#\t One payment - one bet. Minimal bet amount = 0.5.\n#    Bet registration fee (see next paragraph) is substracted from your payment.\n# 2. Register payment as the bet\n#    You need to register the bet for the game round. Choose round by it's timestamp (happens every 5 minutes). \n#    To register you need send DataTransaction from the script account signed by Payment sender and containing the following data:\n#    (<payment_id>, guess), (<payment_id>_round, timestamp_of_the_round)\n# \t timestamp_of_the_round - in UTF8 encoding in bytes(13 bytes)\n#    Guess is a ByteArray in the following format:\n#     type of bet (1 byte), guess (1 byte)\n#     Bet type could be one of the following (in braces possible 'guess' values are defined):\n#     0 - number (number)\n#     1 - red (0) or black (1)\n#     2 - even (0) or odd (1)\n#     3 - 1st half of the desk (0) and 2nd half (1)\n#     4 - 1st third of the desk (0), 2nd third (1), 3rd third (2)\n#     5 - 1st row of the desk (0), 2nd row (1), 3rd row (2)\n#\n# How to get your prise in case you win \n#\n# In case you guess right you can get more money then your bet (see koeff variable in the code).\n# Formula is: (paymentTx.amount - registerBetTxFee) * koeff - dataTxsFees - withdrawTx.fee\n#\n# You win the round defined by your Bet Registration in case the Oracle\n# put equal value to the round's data. Oracle puts DataTransaction where\n#  - the key is the timestamp of the round in UTF8 format converted to ByteArray\n#  - value is ByteArray containing\n#    1) version (1 byte)\n#\t 2) wining value for bet of type0 - number (1 byte)\n#\t 3) wining value for bet of type1 - red/black (1 byte)\n#\t 4) wining value for bet of type2 - even/odd (1 byte)\n#\t 5) wining value for bet of type3 - halfs of the desk (1 byte)\n#\t 6) wining value for bet of type4 - thirds of the desk (1 byte)\n#\t 7) wining value for bet of type5 - rows of the desk (1 byte)\n#\n# You can also get your money back if you just sent Payment, but didn't register it as a bet.\n# In this case you need to do the same as described below, but amount would be the following:\n# paymentTx.amount - dataTxsFees - withdrawTx.fee \n#\n# To get money you need to do the following:\n# 1. Create withdraw - Transfer transaction. Amount of money must be calculated according to type of your bet\n#    and concider fees - fee of withdraw transaction and fees of data transactions (see 2.)\n#    Withdraw transaction must:\n#\t 1) be originated from the Casino account (sender - is the Casino account public key)\n#    2) be signed by Payment sender\n#\t 3) contain Payment transaction id in the second proof.\n#    Don't send withdraw yet, just remember it's id (<withdraw_id>). \n#\t You will send it on step 3, after the DataTransaction. \n# 2. Create and send DataTransaction. This DataTransaction links your Payment to the Withdraw.\n#    Because of this DataTransaction you only able to get money once per payment which won. \n#\t In case you sent DataTransaction but lost your Withdraw transaction (e.g. it is expired),\n#    you can provide another DataTransaction with new link of Payment to Withdraw.\n#    Since DataTransactions are made from the name of the Casino account fees \n#\t will be substracted from your prise.\n#\t DataTransaction must: \n#    1) be originated from the Casino account (sender - is the Casino account public key)\n#    2) be signed by Payment sender\n#    3) contain the following (key, value) pairs:\n#    (<payment_id>_withdraw, <withdraw_id>), (<payment_id>_withdraw_fees, sum_ammount_of_data_txs_fees)\n#\t sum_ammount_of_data_txs_fees - is sum of fees of all DataTransactions for this payment.\n# 3. When DataTransaction is in the blockchain send Withdraw created on step 1.\n#\n# Donation \n# if you find this script useful, you can donate\n# Waves address: 3P5VCmMc7fqqJijHaS3yB8jCwq7rgmLpszx\n\n\nlet me = tx.sender\nlet oracle = extract(addressFromString(\"3NCzaYTNDGtR8zf9yfcqePFjCqFx9S5zhs4\"))\nlet minWithdrawFee = 500000\nlet registerBetTxFee = 500000\n\nmatch(tx) {\n\tcase withdrawTx: TransferTransaction =>\n\t\t# proofs[0] contains signiture by payment sender\n\t\t# proofs[1] contains payment Tx id\n\t\tlet txId = extract(getString(me, toBase58String(tx.proofs[1]) + \"_withdraw\"))\n\t\tmatch(transactionById(tx.proofs[1])) {\n\t\t\tcase paymentTx: TransferTransaction =>\n\t\t\t   let isPaymentTookPlace = txId == toBase58String(tx.id) && sigVerify(tx.bodyBytes, tx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\tlet feesKey = toBase58String(tx.proofs[1]) + \"_withdraw_fees\"\n\t\t\t\tlet dataTxsFees = extract(getInteger(me, feesKey))\n\n\t\t\t\tlet guessUnit = getBinary(me, toBase58String(tx.proofs[1]))\n\t\t\t\t\n\t\t\t\tlet correctAmount = if (!isDefined(guessUnit)) then\n\t\t\t\t{\n\t\t\t\t\t# return back payment\n\t\t\t\t\tpaymentTx.amount - dataTxsFees - withdrawTx.fee\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t# get win prise\n\t\t\t\t\tlet guess = extract(guessUnit)\n\n\t\t\t\t\tlet type = take(guess, 1)\n\t\t\t\t\tlet val = drop(guess, 1)\n\t\t\t\t\tlet key = extract(getString(me, toBase58String(tx.proofs[1]) + \"_round\"))\n\n\t\t\t\t\tlet valComplex = extract(getBinary(oracle, key))\n\n\t\t\t\t\tlet koeff =\n\t\t\t\t\t\tif (type == drop(toBytes(0), 7)) then 36\n\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then 2\n\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then 3\n\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then 3\n\t\t\t\t\t\telse 0\n\n\t\t\t\t\t(paymentTx.amount - registerBetTxFee) * koeff - dataTxsFees - withdrawTx.fee\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t(isPaymentTookPlace || throw(\"There was no bet\")) \n\t\t\t\t&& \n\t\t\t\t((withdrawTx.amount == correctAmount) || throw(\"Amount is incorrect. Correct amount is \" + toString(correctAmount))) \n\t\t\t\t&& \n\t\t\t\t((!isDefined(withdrawTx.feeAssetId) && !isDefined(withdrawTx.assetId)) \n\t\t\t\t|| throw(\"Withdraw and fee must be in WAVES\"))\n\n\t\t\tcase _ => false\n\t\t}\n\n\tcase dtx: DataTransaction =>\n\n\t\tif (size(dtx.data) == 3) then\n\t\t{\n\t\t\t# Data Tx for BET REGISTRATION\n\t\t\t\t\t\t\n\t\t\tlet minBet = \t  50000000\n\t\t\tlet maxSumBet = 1000000000 # max sum bet for round\n\t\t\t\n\t\t\tlet paymentTxIdStr = extract(dtx.data[0].key)\n\t\t\t\n\t\t\tlet guessStr = extract(getString(dtx.data, paymentTxIdStr))\n\t\t\tlet paymentRoundKey = paymentTxIdStr + \"_round\"\n\t\t\tlet paymentRound = extract(getString(dtx.data, paymentRoundKey))\n\t\t\t\n\t\t\tlet sumBetsOld = if isDefined(getInteger(me, paymentRound + \"_betsSum\")) \n\t\t\t\t\t\t\t\tthen extract(getInteger(me, paymentRound + \"_betsSum\")) \n\t\t\t\t\t\t\t\telse 0\n\t\t\tlet sumBetsNew = extract(getInteger(dtx.data, paymentRound + \"_betsSum\"))\n\n\t\t\tlet itsTooLate = isDefined(getString(me, paymentRound + \"_stop\"))\n\t\t\t\n\t\t\tlet isPaymentAlreadyMentioned = isDefined(getString(me, paymentTxIdStr))\n\n\t\t\tlet paymentTx = transactionById(fromBase58String(paymentTxIdStr))\n\t\t\tmatch (paymentTx) {\n\t\t\t\tcase paymentTx : TransferTransaction =>\n\t\t\t\t\t# data-transaction must be signed by payment sender\n\t\t\t\t\tlet isDtxSignedByPayer = sigVerify(dtx.bodyBytes, dtx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\t\tlet correctSumBets = sumBetsOld + paymentTx.amount - dtx.fee # data tx fee is payed by Payment sender from its bet\n\n\t\t\t\t\t(addressFromRecipient(paymentTx.recipient) == me || throw(\"Incorrect recipient of the payment\"))\n\t\t\t\t\t&&\n\t\t\t\t\t(!isPaymentAlreadyMentioned || throw(\"This transfer is already used as a bet\")) \n\t\t\t\t\t&& \n\t\t\t\t\t((sumBetsNew == correctSumBets)\n\t\t\t\t\t|| throw(\"Wrong value for Sum of Bets. Must be \" + toString(correctSumBets)))\n\t\t\t\t\t&&\n\t\t\t\t\t((sumBetsNew < maxSumBet) \n\t\t\t\t\t|| throw(\"Maximum amount of bets for round \" + toString(maxSumBet) + \". With your bet it's \" + toString(sumBetsNew)))\n\t\t\t\t\t&&\n\t\t\t\t\t((dtx.fee == registerBetTxFee) \n\t\t\t\t\t|| throw(\"Fee of bet registration data transaction must be \" + toString(registerBetTxFee)))\n\t\t\t\t\t&&\n\t\t\t\t\t((paymentTx.amount - registerBetTxFee >= minBet) || throw(\"Your Bet amount is less then minimal bet \" + toString(minBet) + \". Payment amount for such bet must be \" + toString(minBet+registerBetTxFee)))\n\t\t\t\t\t&& \n\t\t\t\t\t((!isDefined(paymentTx.feeAssetId) || throw(\"Paymnet must be in WAVES\")))\n\t\t\t\t\t&& \n\t\t\t\t\t(!itsTooLate || throw(\"It's too late to play this round. Try next one\"))\n\n\t\t\t\t\t \n\n\t\t\t\tcase _ => false\n\t\t\t}\t\t\n\t\t}\n\t\telse if (size(dtx.data) == 2) then\n\t\t{\n\t\t\t# Data Tx for WITHDRAW registration\n\n\t\t\t# payment transaction in the first key-value.\n\t\t\t# Data tx must be signed by payment sender\n\n\t\t\tlet isDataCountOk = size(dtx.data) == 2\n\n\t\t\tlet paymentTxIdStr = dropRight(extract(dtx.data[0].key), 9) # drop \"_withdraw\"\n\t\t\tlet feesKey = paymentTxIdStr + \"_withdraw_fees\"\n\t\t\tlet paymentTx = transactionById(fromBase58String(paymentTxIdStr))\n\t\t\tlet newFees = extract(getInteger(dtx.data, feesKey))\n\t\t\tlet oldFeesUnit = getInteger(me, feesKey)\n\t\t\tlet oldFees = if isDefined(oldFeesUnit)\n\t\t\t\t\t\t\tthen extract(oldFeesUnit)\n\t\t\t\t\t\t\telse 0\n\n\t\t\tlet isFeeCorrect = newFees == oldFees + dtx.fee\n\n\t\t\t#if payment already mentioned in the State, the corresponding withdraw tx must not exist\n\t\t\t\n\t\t\tlet withdrawTxIdUnit = getString(me, paymentTxIdStr)\n\t\t\tlet isPaymentAlreadyMentioned = isDefined(withdrawTxIdUnit)\n\n\t\t\tlet withdrawTransactionId = fromBase58String(extract(withdrawTxIdUnit))\n\n\t\t\tmatch (paymentTx) {\n\t\t\t\tcase paymentTx : TransferTransaction =>\n\t\t\t\t\t# data-transaction must be signed by payment sender\n\t\t\t\t\tlet isDtxSignedByPayer = sigVerify(dtx.bodyBytes, dtx.proofs[0], paymentTx.senderPublicKey)\n\n\t\t\t\t\t#if payment correct\n\t\t\t\t\tif (addressFromRecipient(paymentTx.recipient) == me\n\t\t\t\t\t\t&&\n\t\t\t\t\t\t(!isPaymentAlreadyMentioned || !isDefined(transactionById(withdrawTransactionId)) ) \n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisDtxSignedByPayer\n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisFeeCorrect\n\t\t\t\t\t\t&&\n\t\t\t\t\t\tisDataCountOk) \n\t\t\t\t\tthen\n\t\t\t\t\t\tlet guess = extract(getBinary(me, paymentTxIdStr))\n\n\t\t\t\t\t\tlet type = take(guess, 1)\n\t\t\t\t\t\tlet key = extract(getString(me, paymentTxIdStr + \"_round\"))\n\n\t\t\t\t\t\tlet valComplex = extract(getBinary(oracle, key))\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet koeff = \n\t\t\t\t\t\t\tif  \t(type == drop(toBytes(0), 7)) then 36\n\t\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then 2\n\t\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then 3\n\t\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then 3\n\t\t\t\t\t\t\telse 0\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet valReal = \n\t\t\t\t\t\t\tif  \t(type == drop(toBytes(0), 7)) then drop(take(valComplex, 2), 1)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(1), 7)) then drop(take(valComplex, 3), 2)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(2), 7)) then drop(take(valComplex, 4), 3)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(3), 7)) then drop(take(valComplex, 5), 4)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(4), 7)) then drop(take(valComplex, 6), 5)\n\t\t\t\t\t\t\telse if (type == drop(toBytes(5), 7)) then drop(take(valComplex, 7), 6)\n\t\t\t\t\t\t\telse throw(\"Incorrect type of guess provided\")\n\n\t\t\t\t\t\tlet isWin = drop(guess, 1) == valReal\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet isMoneyStillEnough = newFees < (paymentTx.amount - registerBetTxFee) * koeff + minWithdrawFee\n\n\t\t\t\t\t\t(isWin || throw(\"You didn't guess\")) \n\t\t\t\t\t\t&& \n\t\t\t\t\t\t(isMoneyStillEnough || throw(\"Not enough money for withdraw\")) \n\n\t\t\t\t\telse false\n\t\t\t\t\t\n\t\t\t\tcase _ => false\n\t\t\t}\n\t\t}\n\t\telse \n\t\t\tfalse\n\t\t\n\tcase _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)\n\n}\n"},{"name":"guess.ride","dir":"smart-accounts","content":"# in the state of this account, there are two fields  \n# \"question\" - with some question and \n# \"hashed answer\" - with an answer to this question \n# which is hashed by keccak256 algorithm user can send \n# any number of WAVES from this account if he/she has \n# a correct answer in an attachment of TransferTransaction  \n\nlet this=extract(tx.sender)\n\nmatch(tx)\n{\n    case t : TransferTransaction =>\n        let correctAnswer = extract(getBinary(this, \"hashed answer\"))\n        let answer = keccak256(t.attachment)\n\n        correctAnswer == answer \n        && !isDefined(t.assetId)\n    case s: SetScriptTransaction | DataTransaction =>\n        sigVerify(s.bodyBytes, s.proofs[0], s.senderPublicKey)\n    case _ => false\n}\n"}],"smart-assets":[{"name":"FixedPriceTicket.ride","dir":"smart-assets","content":"# This token represents a ticket that can be traded at face value only.\n#\n# Token price is hard coded into the script, and exchange is allowed\n# only at that price. Such a token can be useful for show or sport\n# tickets to help combat ticketing fraud.\n#\n# Additional restriction: a ticket can be burnt only after the show is over.\n#\n\nlet expiration = 1552064400000  # March 8 2019, 8pm Moscow time\nlet price = 1000000000          # 10 WAVES\nmatch tx {\n    case e: ExchangeTransaction =>\n        let pair = e.buyOrder.assetPair\n        let tradedForWaves = ! isDefined(pair.amountAsset) ||\n                             ! isDefined(pair.priceAsset)\n        tradedForWaves && e.price == price\n    case b: BurnTransaction =>\n        b.timestamp > expiration\n    case _: TransferTransaction | MassTransferTransaction => true\n    case _  => false\n}\n"},{"name":"FixedRateExchange.ride","dir":"smart-assets","content":"# This token can be bought/sold for WAVES only at a rate published by\n# asset issuer.\n#\n# The issuer publishes the exchange rate with a data transaction on his\n# account. The actual exchange rate must match the published rate up to\n# 7th significant digit.\n#\n\nlet issuer = Address(base58'3issuerAddress')\nlet assetId = base58'ThisAsset1d'\nmatch tx {\n    case ex: ExchangeTransaction =>\n        let pair = AssetPair(assetId, unit)\n        let rate = extract(getInteger(issuer, \"exchangeRate\"))\n        let rateDiff = rate - fraction(100000000, ex.price, ex.amount)\n        ex.buyOrder.assetPair == pair && rateDiff > -100 && rateDiff < 100\n    case _ => true\n}\n"},{"name":"HotPotatoToken.ride","dir":"smart-assets","content":"# This is a token-game\n# When you receive this token, you have 5000 blocks to transfer it to somebody else,\n# after that 5000 blocks you will have to pay the fee more than 1 Waves to transfer it.\n# you have to pay 10 Waves as fee to burn it, you can transfer it only to an account with >10 Waves\n\nlet minimumWavesBalance = 10_00_000_000\nlet moveTimeInBlocks = 5000\nlet minimalFeeToMove = 1_0_000_000\nlet minimalFeeToBurn = 5_0_000_000\n\n\n\nmatch (tx) {\n    case t:TransferTransaction => {\n\n        # to get a height of blockchain when HotPotato was received we expect transaction id\n        # of incoming transfer transaction in the attachment\n        let txId = t.attachment\n\n        # script can check that current recipient doesnt hold HotPotato\n        # but not now :)\n\n        # let currentRecipientBalance = assetBalance(t.recipient, t.assetId)\n        let currentRecipientWavesBalance = wavesBalance(t.recipient)\n\n        # assetId equals to issue transaction id, so we can get issuer public key (and address) from the issue transaction\n        let transaction = transactionById(extract(t.assetId))\n\n        match (transaction) {\n            case issueTx:IssueTransaction => {\n                # issuer is allowed to send tokens without any additional requirements except signature and recipient Waves balance (should be >= 10)\n                let transactionByIssuer = t.senderPublicKey == issueTx.senderPublicKey\n                if (transactionByIssuer) then {\n                    if (currentRecipientWavesBalance < minimumWavesBalance) then {\n                        throw(\"Current balance is less than minimalWavesBalance\")\n                    }else {\n                        true\n                    }\n                }else if (size(t.attachment) < 32) then {\n                    throw(\"Attachment should contain transaction id \")\n                }else{\n                    # getting incoming transaction by id (from the attachment)\n                    let receiveTx = transactionById(txId)\n                    match (receiveTx) {\n                        case recTx:TransferTransaction | MassTransferTransaction => {\n                            # get the number of block when address get a potato\n                            let receivedBlockNumber = extract(transactionHeightById(recTx.id))\n                            # check that we received assets in allowed span\n                            let receivedAssetInLastNBlocks = (height - receivedBlockNumber) <= moveTimeInBlocks && t.assetId == recTx.assetId\n                            let feeMore1Waves = t.fee >= minimalFeeToMove\n                            if (!receivedAssetInLastNBlocks && !feeMore1Waves) then {\n                                throw(\"You got potato long time ago, now you have to pay 1 WAVES fee\")\n                            }else {\n                                receivedAssetInLastNBlocks || feeMore1Waves\n                            }\n                        }\n                        case _ => throw(\"Receive tx should be a transfer\")\n                    }\n                }\n            }\n            case _ => throw(\"Not issue tx\")\n        }\n    }\n    # we allow to burn a token only if fee > 5 waves\n    case burn: BurnTransaction => {\n        if (burn.fee < minimalFeeToBurn) then {\n            throw(\"You have to pay 5 WAVES to burn this token\")\n        }else{\n            true\n        }\n    }\n    # MassTransfer and SetAssetScript transactions are allowed only for issuer\n    case mass: MassTransferTransaction | SetAssetScriptTransaction => {\n        let transaction = transactionById(extract(mass.assetId))\n\n        match (transaction) {\n            case issueTx:IssueTransaction => {\n                mass.senderPublicKey == issueTx.senderPublicKey\n            }\n            case _ => throw(\"Bad issue tx type\")\n        }\n    }\n    case _ => throw(\"You only can transfer this token\")\n  }"},{"name":"Medal.ride","dir":"smart-assets","content":"# This is a medal token.\n#\n# Medals are awarded to people using Transfer or MassTransfer. The issuer\n# can mint new medals or burn unused ones. The medal asset should have\n# zero decimals.\n#\n# A person who's awarded a medal can not transfer nor sell it,\n# but can give it back to the issuer.\n#\n\nlet master = addressFromString(\"3masterAddress\")\nmatch tx {\n    case t: TransferTransaction =>\n        t.sender == master || t.recipient == master\n    case mt: MassTransferTransaction =>\n        mt.sender == master\n    case ex: ExchangeTransaction => false\n    case _ => true\n}\n"},{"name":"PredictionToken.ride","dir":"smart-assets","content":"# This token is a lottery ticket which wins if, on Feb 18th, the\n# WAVES/WUSD price at the DEX reaches $3 for 1 WAVES.\n#\n# The ticket issuer files two orders:\n# - A sell order at say 1 WAVES so that people can buy tickets\n# - A buy order at say 2 WAVES. The matching sell order should have\n#   as its proof #1 the ID of an Exchange transaction which:\n#   - is signed by the DEX matcher\n#   - occurred on Feb 18th\n#   - traded WAVES for WUSD\n#   - has price above $3 / WAVES\n#\n# So people get their tickets by buying them from the issuer for\n# 1 WAVES. They can sell or transfer them freely to other folks\n# for any price they like. However, when they try to sell back to the\n# issuer, the conditions above are checked.\n#\n#\n# Notes:\n# =====\n# - Tickets can check any condition, not necessarily DEX prices --\n#   e.g. some oracle. This example script just uses DEX as an oracle.\n# - It is important to check that the proof transaction indeed comes\n#   from DEX. Otherwise it's possible to craft a self-signed exchange\n#   transaction with the desired price and use it as proof.\n# - Such proofs of price only make sense for liquid markets that are\n#   expensive to manipulate.\n# - Currently our DEX does not allow filing buyback orders. They get\n#   rejected by its asset script checking routine.\n#\n#\n# Enough chatting, let's check out the code:\n# ------------------------------------------------------------------\n#\nlet Issuer = addressFromString(\"3PED7PH1MGsa9Q2EL46q89qLvS4z9jmSnjD\")\n\n                            # The story goes here:\n                            #\nlet DexPublicKey =          # IF, at our DEX,\n    base58'7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy'\nlet Start = 1550437200000   # between Feb 18 00:00 MSK\nlet End   = 1550523600000   # and Feb 18 24:00 MSK,\nlet Pair =                  # price of WAVES against WUSD\n    AssetPair(unit, base58'Ft8X1v1LTa1ABafufpaCWyVj8KkaxUWE6xBhW6sNFJck')\nlet TargetPrice = 300       # reaches 3 WUSD for 1 WAVES\nlet WinAmount = 200000000   # THEN this token can be sold for 2 WAVES\n\nmatch tx {\n    case tx: ExchangeTransaction =>\n        let proofId = tx.sellOrder.proofs[1]\n        let proof = transactionById(proofId)\n        let proven = match proof {\n            case ex: ExchangeTransaction =>\n                ex.senderPublicKey == DexPublicKey &&\n                ex.buyOrder.assetPair == Pair &&\n                ex.timestamp >= Start &&\n                ex.timestamp <= End &&\n                ex.price >= TargetPrice\n            case _ => false\n        }\n        let checked =\n            tx.timestamp >= Start &&\n            tx.price == WinAmount\n        tx.buyOrder.sender != Issuer || checked && proven\n    case _ => true\n}\n"},{"name":"RecipientSignature.ride","dir":"smart-assets","content":"\n# General idea of this token is to allow transfer only with recipient's permisson. \n# Token ownership can be used as a proof of physycal object ownership and token transfer as a proof of 'real world' object transfer.\n\n# To use this token:\n# 1. Sender creates tx without proof and sends it to recipient\n# 2. Recipient calculates signature, adds his public key and signature to attachment field. Sends tx back to sender.\n# 3. Sender signs tx with attachment. Tx can now be sent to blockchain\n\n# Set network byte. 87 for mainnet\nlet NETWORKBYTE = takeRight(toBytes(87), 1)\n\nmatch (tx) {\n    # Only allow transfer transactions\n    case t:TransferTransaction => {\n        # Since smart assets don't have access to proofs, attachment is used, but attachment is also signed.\n        # For that reason we will verify signature against tx without attachment\n        let txWithoutAttachment = dropRight(t.bodyBytes, 97) + takeRight(toBytes(0), 1)\n\n        # Attachment contains recipient public key and signature\n        let recipientPublicKeyAndSignature = t.attachment\n        let recipientPublicKey = take(recipientPublicKeyAndSignature, 32)\n        let recipientSignature = takeRight(recipientPublicKeyAndSignature, 64)\n\n        # Get recipient address from public key in attachment\n        let recipientPublicKeyHash = take(keccak256(blake2b256(recipientPublicKey)), 20)\n        let rpkWithVersionAndByte = takeRight(toBytes(1), 1) + NETWORKBYTE + recipientPublicKeyHash\n        let checksum = take(keccak256(blake2b256(rpkWithVersionAndByte)), 4)\n        let recipientAddressFromPublicKey = rpkWithVersionAndByte + checksum\n        let recipientAddressFromTx = addressFromRecipient(t.recipient).bytes\n        \n        # Verify that tx.recipient equals recipient from attsachment\n        if (recipientAddressFromPublicKey != recipientAddressFromTx) then throw(\n            \"Recipient address error:\" + toBase58String(recipientAddressFromPublicKey)\n            ) else {\n        # Verify recipient signature\n        if (!sigVerify(txWithoutAttachment, recipientSignature, recipientPublicKey))  then  throw(\n            \"Invaid recipient signature:\" + toBase58String(recipientSignature) + \"\\n BodyBytes:\" + toBase64String(txWithoutAttachment)\n            ) else {\n            true\n        }}\n    }\n    # No exchange or masstransfer\n    case _ => false\n  }\n"},{"name":"Taxation.ride","dir":"smart-assets","content":"# This script allows to apply taxation models to assets\n# Token owners can transfer it only if they pay taxes to the issuer\n# The tax size is defined by token issuer in data transaction\n\nmatch (tx) {\n    # we allow only mass transfer transactions\n    # first transfer in MassTransfer should always go to the issuer\n    case mtt:MassTransferTransaction => {\n        let firstRecipient = mtt.transfers[0].recipient\n        let firstAmount = mtt.transfers[0].amount\n        let assetId = extract(mtt.assetId)\n        let issueTransaction = transactionById(assetId)\n\n        # assetId equals to issue transaction id, so we can get issuer public key (and address) from the issue transaction\n        match(issueTransaction) {\n            case issueTx: IssueTransaction => {\n                let issuerAddress = addressFromPublicKey(issueTx.senderPublicKey)\n                # to set tax amount, issuer should make a data transaction with integer value by key matching assetId\n                let taxSize = extract(getInteger(issuerAddress, toBase58String(assetId)))\n\n                firstRecipient == issuerAddress # recipient for the first transfer should be the issuer address\n                &&\n                firstAmount >= mtt.totalAmount / 100 * taxSize # tax amount can't be less than defined in data transaction\n            }\n            case _ => false\n        }\n    }\n    case _ => false\n  }"},{"name":"VerifiedTrading.ride","dir":"smart-assets","content":"# Set Smart asset to trade only with BetterTokens verified assets and Waves.\n#\n# BetterTokens Oracle address.\nlet addr = Address(base58'3P6t5mKGwVDkyjFhtUqw4NnecyC3DRpLfkw')\n\nmatch (tx) {\n    case e:ExchangeTransaction => \n        # Determine if Smart asset is paired with Waves.\n        let withWaves = (!isDefined(e.sellOrder.assetPair.priceAsset) || !isDefined(e.sellOrder.assetPair.amountAsset))\n\n        if(withWaves == false) then {\n            # If paired with another token, check BetterToken status.\n            #\n            # We cannot determine if Smart asset is amount or price asset in the pair\n            # that is why we check in both places.\n            let priceAssetKey = \"status_<\" + toBase58String(extract(e.sellOrder.assetPair.priceAsset)) + \">\"\n            let priceAssetInOracle = (getInteger(addr, priceAssetKey) == 2)\n\n            let amountAssetKey = \"status_<\" + toBase58String(extract(e.sellOrder.assetPair.amountAsset)) + \">\"\n            let amountAssetInOracle = (getInteger(addr, priceAssetKey) == 2)\n            \n            priceAssetInOracle || amountAssetInOracle\n        } else {\n            true\n        }\n    case _ => true\n}"}]}